<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Cygwin (vers 1st September 2003), see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=us-ascii">
<title>Prolog+CG Manual</title>
</head>
<body text="#000000" link="#0000FF" vlink="#800080">
<p align="center">&nbsp;</p>
<p align="center"><img src="ImgPrlg.png" width="130" height=
"172"></p>
<p align="center">&nbsp;</p>
<p align="center"><big><big><big><big><font face=
"Garamond"><b>PROLOG+CG</b></font></big></big></big></big></p>
<p align="center"><big><big><big><font face=
"Garamond"><b>User's Manual</b></font></big></big></big></p>
<p align="center">&nbsp;</p>
<p align="center"><big><big><big><font face="Garamond">Dr. Adil
KABBAJ</font></big></big></big></p>
<p align="center">&nbsp;</p>
<p align="center"><big><big><big><font face=
"Garamond">Version&nbsp; 2.0</font></big></big></big></p>
<p align="center"><big><big><big><font face=
"Garamond">01/12/2000</font></big></big></big></p>
<p align="center">&nbsp;</p>
<p align="center"><big><font face=
"Garamond"><strong>E-mail:</strong></font> <a href=
"mailto:akabbaj@insea.ac.ma">akabbaj@insea.ac.ma</a></big></p>
<p align="center"><big>Web : <a href=
"http://prologpluscg.sourceforge.net/">http://prologpluscg.sourceforge.net/</a></big></p>
<p align="center">&nbsp;</p>
<p align="center"><big><big><big><font face="Garamond">I.N.S.E.A,
Rabat, Morocco</font></big></big></big></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p align="center"><big><big><big><big><a name=
"Contents"></a><font face=
"Garamond"><b>Contents</b></font></big></big></big></big></p>
<p align="center">&nbsp;</p>
<ol>
<li><big><a href="#Introduction"><font face=
"Garamond">Introduction</font></a></big></li>
<li><big><font face="Garamond"><a href="#environment">Prolog+CG
environment and its installation</a></font></big></li>
<li><big><a href="#Elementary"><font face="Garamond">Elementary
data types</font></a></big></li>
<li><a href="#Term"><big><font face="Garamond">Composed data type :
Term</font></big></a></li>
<li><a href="#List"><big><font face="Garamond">Composed data type :
List</font></big></a></li>
<li><big><a href="#Primitive"><font face="Garamond">Primitive
operations</font></a></big></li>
<li><big><a href="#Facts"><font face="Garamond">Facts and inference
Rules</font></a></big></li>
<li><big><a href="#Sample1"><font face="Garamond">Samples
I</font></a></big></li>
<li><big><a href="#Specialization"><font face=
"Garamond">Specialization rules</font></a></big></li>
<li><big><a href="#Instantiation"><font face=
"Garamond">Instantiation rules</font></a></big></li>
<li><a href="#CG"><big><font face="Garamond">Composed data type :
Conceptual Graph (CG)</font></big></a></li>
<li><big><a href="#Sample2"><font face="Garamond">Samples
II</font></a></big></li>
<li><big><a href="#CGoperations"><font face="Garamond">CG
operations</font></a></big></li>
<li><big><a href="#Sample23"><font face="Garamond">Samples
III</font></a></big></li>
<li><a href="#metaOperations"><big><font face=
"Garamond">Meta-operations</font></big></a></li>
<li><a href="#visualDebug"><font face="Garamond"><big>The visual
debugger of PROLOG+CG</big></font></a></li>
<li><a href="#ExpertMode"><font face="Garamond"><big>The Expert
System Mode</big></font></a></li>
<li><big><a href="#Objects"><font face="Garamond">Objects, messages
and object-based programming</font></a></big></li>
<li><big><a href="#Sample3"><font face="Garamond">Samples
IV</font></a></big></li>
<li><big><a href="#Inheritance"><font face="Garamond">Inheritance
rules and Object-oriented programming</font></a></big></li>
<li><a href="#sample4"><big><font face="Garamond">Samples
V</font></big></a></li>
<li><a href="#PROLOG+CGandJAVA"><big><font face="Garamond">From
PROLOG+CG to JAVA and back</font></big></a></li>
</ol>
<p><a href="#Appendix"><big><font face="Garamond">Appendix&nbsp;:
The grammar of PROLOG+CG</font></big></a></p>
<p>&nbsp;</p>
<p><big><font face="Garamond">Please report any bugs, problems or
suggestions to : <a href=
"http://prologpluscg.sourceforge.net/contact.html">Ulrik
Petersen</a></font></big></p>
<P><big>Please note that Prolog+CG version 2.0 is being replaced by a new
version under development.  The new version will be part of the <A
HREF="http://amine-platform.sourceforge.net">Amine-platform<A/>.</big></P>
<p>&nbsp;</p>
<p><strong><big><big><big><font face="Garamond">1. <a name=
"Introduction">Introduction</a></font></big></big></big></strong></p>
<p><font face="Garamond">PROLOG (PROgramming in LOGic) is a
programming language that has been designed first (around 1972) for
natural language processing and theorem proving. It has been used,
since that time in many fields of Artificial Intelligence (AI).
Now, PROLOG is a standard programming language in AI.</font></p>
<p><font face="Garamond">This manual is not about PROLOG, even if a
quick introduction of this language is given as the basic elements
of PROLOG+CG are introduced. Several books and documentation
concerning PROLOG language are available. This manual is about a
descendant of PROLOG : <strong>PROLOG+CG</strong> which is
<strong><em>a conceptual and an object-oriented extension of
PROLOG</em></strong>. Indeed, to achieve more expressive power, the
PROLOG language has been extended, in the past, in at least two
directions :</font></p>
<ul>
<li><font face="Garamond"><strong><big><i>Conceptual extension</i>
:</big></strong> a goal can be represented by a term (a predicate)
or by a complex structure, like typed feature structure [1, 2, 3,
10, 18].</font></li>
</ul>
<ul>
<li><font face="Garamond"><big><strong><i>Contextual extension</i>
:</strong></big> it is illustrated first by object-based PROLOG
[14, 16, 4, 5] where a Prolog program is partitioned into objects
(or worlds, theories, modules, bases, spaces or other similar
terms), each object contains a set of rules. A goal is then
resolved in the context of a specific object. Contextual extension
of PROLOG is illustrated also by object-oriented PROLOG [7, 15, 17]
where inheritance between objects is considered.</font></li>
</ul>
<p><font face="Garamond"><em><strong>PROLOG+CG is a conceptual
extension of PROLOG in the sense that</strong></em> it integrates
Conceptual Graphs (CG) at the basic level. Conceptual Graph (CG)
formalism (for background knowledge about CG, please see : <a href=
"http://www.jfsowa.com/cg/index.htm">http://www.jfsowa.com/cg/index.htm</a>)
is a synthesis of several works on semantic networks. CG has been
used in many fields of AI, especially natural language processing
and knowledge base systems. An integration of CG to Prolog is very
interesting. In the Conceptual Graph community, some systems [6, 8,
9] incorporated a deductive component that interprets a set of
rules, all the goals of a rule are represented by simple Conceptual
Graphs (CG). However, these components do not subsume PROLOG and
were not presented as extensions of PROLOG. For instance, no work
has been done in the past to develop a Prolog version that provides
CG as a basic data structure, beside term and list. PROLOG+CG
fulfills this gap in the CG research (i.e., a need for a CG based
extension of Prolog) : CG can be used to represent goals (beside
terms) and can be used and manipulated as basic data structures,
with operations like maximal join, projection (or more precisly
subsumption), generalization and unification operations.</font></p>
<p><font face="Garamond">PROLOG+CG is a contextual extension of
PROLOG in the sense that it integrates notions like objects and
inheritance.</font></p>
<p><font face="Garamond">Also, PROLOG+CG integrates JAVA :
PROLOG+CG can be called from a Java program and a Prolog+CG program
can call Java classes.</font></p>
<p><font face="Garamond">The integration of <font color=
"#FF0000"><strong>Prolog</strong></font>, <strong><font color=
"#FF0000">object oriented programming</font></strong>, the
<font color="#FF0000"><strong>manipulation of CG</strong></font>
and <font color="#FF0000"><strong>Java</strong></font> provides a
powerful development environment for the creation of
knowledge-based applications and their integration on the web. Java
allows the development of multi-platform applications as well as
the capabilities of object-oriented languages. Prolog provides the
full power of a logic programming language well suited for natural
language processing, inference and symbolic manipulations. CGs
provide the expressive power of an advanced knowledge
representation language (advanced semantic nets, type hierarchy,
schemas, notion of context, etc.).</font></p>
<p><font face="Garamond">PROLOG+CG is implemented in JAVA 2. A beta
version 2.0 is available throw the site&nbsp; <a href=
"http://prologpluscg.sourceforge.net/">PROLOG+CG</a>.</font></p>
<p>&nbsp;</p>
<p><big><big><font face="Garamond"><b>2. <a name=
"environment"></a>Prolog+CG environment and its
installation</b></font></big></big></p>
<p><font face="Garamond">The integrated environment of PROLOG+CG
consists of a text editor, a "compiler", the debugger and the
interpreter. The compiler performs a syntactic analysis of the
program and if the analysis is successful, it generates an object
file that contains an internal representation of the program, in
terms of Java structures (vector, hashtable, etc.). Thereafter, the
interpreter works on the object file.</font></p>
<p><font face="Garamond">At the interface level, the environment
provides a split pane; the top pane is used to create/open/edit a
program while the bottom pane is used as a console : the user asks
a request and the system gives the answer (Figure 1). During the
compilation, the console pane becomes a compiler pane where
messages concerning this task are written. If the compilation has
been successfull, the user has to click inside the pane to switch
to the console pane.</font></p>
<p><font face="Garamond">The environment provides also a debug
window (accessible from the Build menu) and a window that shows the
primitive operations of the language (accessible from the Help
menu).</font></p>
<p><font face="Garamond">Figure 1 gives a snapshot of the PROLOG+CG
environment.</font></p>
<p align="center"><img src="snapshot1.png" alt=
"snapshot1.png (38666 octets)"></p>
<p align="center"><font face="Garamond"><b>Figure 1: PROLOG+CG
Environment</b></font></p>
<p align="left"><font face="Garamond">Some of the commands/buttons
of the environment are the following (the others are the standards
buttons for file and edition processing) :</font></p>
<p><img src="compile.png"><font face="Garamond">&nbsp;Compile a
Prolog+CG File to produce an object file (if it doesn't exist
already)</font></p>
<p><img src="shortcut.png"><font face="Garamond">&nbsp;Execute the
interpreter to answer a question</font></p>
<p><img src="help.png"><font face="Garamond">&nbsp;Help</font></p>
<p><font face="Garamond">More information on the environment is
provided in the next sections.</font></p>
<p>&nbsp;</p>
<p><big>Installation of PROLOG+CG</big></p>
<p>Prolog+CG is implemented with JAVA 2. So the JRE of JAVA 2
should be installed first. Then you have to download the
PrologPlusCG directory and to put it in your current directory (C
for Windows for instance). PrologPlusCG can be executed with the
following command (from the DOS Console) : &nbsp;
<strong>java&nbsp; PrologPlusCG/PrologPlusCG</strong></p>
<p>&nbsp;</p>
<p><big><big><font face="Garamond"><b>3. <a name=
"Elementary"></a>Elementary data types</b></font></big></big></p>
<p><font face="Garamond">Currently, the elementary data types are
Number (unsigned or negative integer or real : 23, -45, 02.45,
-564.675, etc.), Boolean (true, false), <a href="#Identifier">a
constant identifier</a> and <a href="#string">String</a>. A
<a href="#variable">variable identifier</a> is also considered in
this section.</font></p>
<ul>
<li><font face="Garamond">A</font> <a name="string"></a><font face=
"Garamond"><strong><i>string</i></strong> is any sequence of
characters surrounded by double-quotes.</font></li>
</ul>
<p><font face="Garamond">Example : "this is a string".</font></p>
<p><font face="Garamond">&nbsp;</font></p>
<ul>
<li><font face="Garamond">A <a name=
"Identifier"></a><strong><em>constant</em>
<i>identifier</i></strong> &nbsp; is any sequence of letters,
digits or underscore (_) that begins with two letters.</font></li>
</ul>
<p><font face="Garamond">Examples of good identifiers :</font>
<font size="2" face="Courier New">pr32, papa, is_good,
pp34_65</font><font face="Garamond">.</font></p>
<p><font face="Garamond">Examples of illegal identifiers :</font>
<font size="2" face="Courier New">p45, _rt, p_rt, _rrt.</font></p>
<p>&nbsp;</p>
<p><font face="Garamond">The <a name="variable"></a><font face=
"Garamond"><i>identifier of a variable</i></font> can be either
:</font></p>
<ul>
<li><font face="Garamond">An underscore followed optionally by a
sequence of letters, digits or underscores.</font></li>
</ul>
<ul>
<li><font face="Garamond">A letter.</font></li>
</ul>
<ul>
<li><font face="Garamond">A letter followed by a digit or an
underscore, and followed optionally by a sequence of letters,
digits or underscores.</font></li>
</ul>
<p><font face="Garamond">Examples of good variable identifiers
:</font> <font size="2" face="Courier New">_var1, _, _324, _ce_ci,
x, x3, x_var</font><font face="Garamond">.</font></p>
<p><font face="Garamond">Note : The grammar of PROLOG+CG is given
in <a href="#Appendix">Appendix 1</a>.</font></p>
<p>&nbsp;</p>
<p><a name="ComposedData"></a><font face=
"Garamond"><big><strong>Composed data types of PROLOG+CG are
:</strong></big> <a href="#Term">term</a>, <a href="#List">list</a>
, <a href="#CG">set</a>, <a href="#CG">concept</a> and&nbsp;
<a href="#CG">CG</a>. They are introduced in the next sections
(sets and concepts are considered in CG section).</font></p>
<p>&nbsp;</p>
<p><font face="Garamond"><strong>Example :</strong> Figure 2 shows
a simple Prolog+CG program that introduces the basic data types of
Prolog+CG : the program contains the fact "prologCGData" that has
one argument : a list of different elements : an integer, a
constant identifier, a string, a boolean, a image file name (see
the remark below), a list, a predicate or term and a conceptual
graph (CG). The program contains also a rule that defines the goal
"dataExple/1" : it search the fact "prologCGData" and call the
primitive goal "member" to access (with backtracking) all the
elements contained in the list.</font></p>
<p><font face="Garamond">The editor of Prolog+CG allows for some
hypertext actions. For instance, when the data is a file name of a
multi-media data, like "ImgPrlg.png", the user can see the content
of this file in a separate window simply by selecting the whole
name and by doing a click on the left-button of the mouse. Figure 2
shows the result of theses actions in the case
"ImgPrlg.png".</font></p>
<p>&nbsp;</p>
<p align="center"><img src="MMDataEnv.png" alt=
"MMDataEnv.png (55388 octets)"></p>
<p align="center"><font face="Garamond"><b>Figure 2: The
"hyper-text editor" and basic data in PROLOG+CG</b></font></p>
<p>Now, to ask some questions about the above program, you have
first to compile it : choose "Build/Compile" from the menu or just
press on the corresponding button <img src="compile.png"> . Then
click in the bottom panel to switch to Console panel and write your
request just after the last prompt "?- ". To activate the
interpreter for responding to your request, press on the key
"return/enter", or choose "Build/Answer Question" or just press on
the corresponding button <img src="shortcut.png"> .</p>
<p>Here is the result of one question about the above program :</p>
<p style="border: thin none"><small><font face="Courier New">?-
prologCGData(L).<br>
{L = (23, John, "John is the Hero", false, "ImgPrlg.png", (iccs,
2000), book(John, KR, 2000),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Write]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Book]-attr-&gt;[New],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Man : John])}</font></small></p>
<p style="border: thin none"><small><font face=
"Courier New">?-</font></small></p>
<p style="border: thin none">&nbsp;</p>
<p><big><big><b><font face="Garamond">4.&nbsp; <a name=
"Term"></a>Term</font></b></big></big></p>
<p><font face="Garamond">A term is an <a href="#Identifier">a
constant identifier</a> followed optionally by a list of arguments.
An argument is either an <a href="#Elementary">elementary data
type</a>, a <a href="#variable">variable</a> or a <a href=
"#ComposedData">composed data type</a>.</font></p>
<p><strong><font face="Garamond">Examples of correct terms
:</font></strong></p>
<p><font size="2" face="Courier New">Prop4, Papa(Abdou),
Publisher(Addison, "Conceptual Structure", 1984),</font></p>
<p><font size="2" face="Courier New">like(Kim, (banana, tomato,
juice), [Man: Kim]&lt;-agnt-[Work]-manr-&gt;[Hard]),</font></p>
<p><font size="2" face="Courier New">phrase("kha eats banana",
st(np("kha"), vp(vb("eats"), &nbsp;&nbsp;
np("banana"))),[Man:kha]&lt;-agnt-[Eat]-obj-&gt;[Banana]
)</font></p>
<p>&nbsp;</p>
<p><big><big><font face="Garamond"><b>5. <a name=
"List"></a>List</b></font></big></big></p>
<p><font face="Garamond">A list can be composed of zero, one or
several elements separated by comma. An element of a list is like
an argument of a term; it is either an <a href=
"#Elementary">elementary data type</a>, a <a href=
"#variable">variable</a> or a <a href="#ComposedData">composed data
type</a>.</font></p>
<p><strong><font face="Garamond">Examples of correct lists
:</font></strong></p>
<p><font size="2" face="Courier New">(), (tati), (titi, 34, (356,
ps(note(67), (2, 4)), "ha ha")),</font></p>
<p><font size="2" face="Courier New">(exp32, [Dat = (23, 12,
84)]&lt;-birthOf-[Boy:Cham], 54)</font></p>
<p>&nbsp;</p>
<p><big><big><strong>6.</strong> <a name=
"Primitive"></a><font face="Garamond"><b>Primitive
operations</b></font></big></big></p>
<p><font face="Garamond">Figure 3 shows the window that is given to
the user when he asks for the primitives of the language, either by
choosing the menu action Help/Primitives or Windows/Primitives.
Each primitive operation is given with its signature (number and
types of the arguments). In this section, we consider only the
arithmetic, relational, logical, list, stringIdent and multi-media
primitive operations. The other types of primitives are introduced
later.</font></p>
<p align="center"><img src="EnvPrimHier2.png" alt=
"EnvPrimHier2.png (11302 octets)"></p>
<p align="center"><font face="Garamond"><b>Figure 3: Primitive
operations</b></font></p>
<p><font face="Garamond">PROLOG+CG adopts a prefix notation to
formulate an expression. Thus, the infix expression : 3 + (4
&ndash; 5) should be formulated in PROLOG+CG as : add(3, sub(4,
5)). As shown below, the primitive goal&nbsp; "val(Var, Expr)"
&nbsp; evaluates the expression Expr and associates its value to
the variable Var. This is how arithmetic computation is done in
PROLOG+CG.</font></p>
<p><font size="2" face="Courier New">?- val(x, add(4, mul(5,
3))).</font></p>
<p><small><font face="Courier New">{x = 19}</font></small></p>
<p><font face="Garamond"><strong>Recall :</strong> the request must
terminates with a point (.) . To activate the interpreter and get
an answer, the user can either choose the menu action "Build/Answer
Question", or press the button <img src="shortcut.png">, or just
press "return" key. The interpreter returns</font> <font size="2"
face="Courier 10cpi">{x = 19}</font><font face=
"Courier New"><small><br>
<br>
?-val(x, mul(-4, add(6, 4.68))).<br>
<br>
{x = -42.72}<br>
<br>
?-eq(x, 34), val(y, div(765, x)).<br>
<br>
{x = 34, y = 22.5}<br>
<br>
?-eqv(x, 54).<br>
<br>
Error: any variable in an expression should have a value.<br>
<br></small></font><font face="Garamond">Note the difference
between the two primitives "eq" and "eqv" : <strong>eq</strong>
corresponds to the unification operation while <strong>eqv</strong>
corresponds to the identity test; the two arguments of
<strong>eqv</strong> should have a value.</font></p>
<p><font face="Courier New"><small><br>
?-eq(x, 54), eqv(x, 54).<br>
<br>
{x = 54}<br>
<br>
?-sup(43, -54).<br>
<br>
{}<br>
<br>
?-inf(-54, -34).<br>
<br>
{}<br>
<br>
?- eq(x, 34), eq(y, 54), dif(x, y).<br>
<br>
{x = 34, y = 54}<br>
<br>
?- eq(54, x), val(y, sub(56, 2)), not(eq(x, y)).<br>
<br>
no.<br>
<br>
?- eq(54, x), val(y, sub(56, 2)), not(dif(x, y)).<br>
<br>
{x = 54, y = 54}</small></font></p>
<p><font size="2" face="Courier New">?- eq(papa(Hicham, x), papa(y,
Nour)).</font></p>
<p><font size="2" face="Courier New">{x = Nour, y =
Hicham}</font></p>
<p><font size="2" face="Courier New">?- eq((1, 2, 3, 4, 5),
(x,y|z)).</font></p>
<p><font size="2" face="Courier New">{x = 1, y = 2, z = (3, 4,
5)}</font></p>
<p><font size="2" face="Courier New">?- dif(papa(Hicham, x),
papa(y, Nour)).</font></p>
<p><font size="2" face="Courier New">no</font></p>
<p><font size="2" face="Courier New">?- dif(papa(Hicham, x),
papa(Wasouf, Nour)).</font></p>
<p><font size="2" face="Courier New">{}</font></p>
<p><strong>Note :</strong> the primitive goal&nbsp; <strong>dif(x,
y)</strong>&nbsp; is equivalent to :
<strong>not(eq(x,y))</strong>.<font face="Courier New"><small><br>
<br>
?-fail.<br>
<br>
no.<br>
<br>
?-stringToLetters("papa", L).<br>
<br>
{L = ("p", "a", "p", "a")}<br>
<br>
?-stringToLetters(x, ("m", "a", "i")).<br>
<br>
{x = "mai"}<br>
<br>
?-identToLetters(papa, L).<br>
<br>
{L = ("p", "a", "p", "a")}<br>
<br>
?-identToLetters(c, ("p", "a", "p", "i")).<br>
<br>
{c = papi}</small></font></p>
<p>&nbsp;</p>
<p><font face="Garamond" size="3"><strong>Examples of List
operations :</strong></font></p>
<p><small><font face="Courier New">?- member(3, (2, 3, 4, 5)).<br>
<br>
{}<br>
<br>
?- member(6, (2, 3, 4, 5)).<br>
<br>
no.<br>
<br>
?-member(x, (2, 3, 4)).<br>
<br>
{x = 2}<br>
{x = 3}<br>
{x = 4}</font></small></p>
<p><small><font face="Courier New">?- length((4, 5, 6, 7), x).<br>
<br>
{x = 4}</font></small></p>
<p>&nbsp;</p>
<p><strong>Multi-media primitive operations : show/2 and
close/1</strong></p>
<p>Note : This is just a preliminary work on the integration of
multi-media in PROLOG+CG.</p>
<p>The following program illustrates this interesting aspect of the
language (sound and video will be integrated in the next version).
Again, please note that the text editor enables the user to see, in
auxiliary windows, the content of the media files : just select the
file name (without the double quotes) and do a click on a
let-button of the mouse. As shown in Figure 4, the program contains
a fact represented by a conceptual graph (<a href="#CG"><font face=
"Garamond">CG</font></a>) which states that PrologPlusCG is a
CGTool with an icon (represented by "ImgPrlg.png"), a manual and a
Java Code.</p>
<p>The rule that defines the goal "MMCGExample" searchs for the
above fact, shows the image "ImgPrlg.png" in the window "wnd1" and
the text file "DocTest.txt" in the window "wnd2". It then waits for
an input from the user and then closes the two windows and writes a
message. What is relevant here is the use of the two primitive
goals : "show/2" and "close/1".</p>
<p><strong>show :&nbsp;</strong> show(Window_Identifier,
MMFileId_String).</p>
<p><strong>close :</strong> close(Window_Identifier)</p>
<p align="center"><img src="MMPrg.png" alt=
"MMPrg.png (12633 octets)"></p>
<p align="center"><font face="Garamond"><b>Figure 4 : A multi-media
program</b></font></p>
<p align="left">&nbsp;</p>
<p align="left"><font face="Garamond">The interpretation of the
request "MMCGExample." by PROLOG+CG gives the following result
:</font></p>
<p align="center"><img src="MMPrgExec.png" alt=
"MMPrgExec.png (66957 octets)"></p>
<p align="center"><font face="Garamond"><b>Figure 5 : Execution of
the multi-media program</b></font></p>
<p align="center">&nbsp;</p>
<p><big><big><strong>7. <a name="Facts"></a></strong><font face=
"Garamond"><b>Facts and inference Rules</b></font></big></big></p>
<p><font face="Garamond">As in PROLOG, a PROLOG+CG program is
composed mainly of <big><i>facts</i></big> and <big><i>inference
rules</i></big>.</font></p>
<p><font face="Garamond"><em><strong>A fact</strong></em>&nbsp; is
a term or a CG followed by a point. <strong><em>An inference
rule</em></strong> is composed of a head and a tail, separated by
the if symbol ":-" and it terminates with a point. The
<big><i>head</i></big> of a rule is a term or a CG and the
<big><i>tail</i></big> is a conjunction of elements, an element can
be a term, a CG or a variable. The next section gives a classic
example of a Prolog program, formulated in Prolog+CG without the
use of CGs. In later sections, we define CG and we present their
use in Prolog+CG programs.</font></p>
<p>&nbsp;</p>
<p><big><big><font face="Garamond"><b>8. <a name=
"Sample1"></a>Samples I</b></font></big></big></p>
<p><font face="Garamond">The following program can be found in
Samples/Meal.prlg. It is a classic example, proposed first by
Colmerauer [Colmerauer, 85]. The user can load the example (by
opening the file Meal.prlg) and compile it, or he can write and
edit the program in the `Program pane'.</font></p>
<p><font size="2" face="Courier New">meal(a, m, d) :-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="6%"></td>
<td valign="top" width="94%"><font size="2" face=
"Courier New">appetizer(a),</font>
<p><font size="2" face="Courier New">main(m),</font></p>
<p><font size="2" face="Courier New">dessert(d).</font></p>
</td>
</tr>
</table>
<p><font size="2" face="Courier New">main(m) :- fish(m).</font></p>
<p><font size="2" face="Courier New">main(m) :- meat(m).</font></p>
<p><font size="2" face=
"Courier New">appetizer(radishes).</font></p>
<p><font size="2" face="Courier New">appetizer(pate).</font></p>
<p><font size="2" face="Courier New">fish(sole).</font></p>
<p><font size="2" face="Courier New">fish(tuna).</font></p>
<p><font size="2" face="Courier New">meat(pork).</font></p>
<p><font size="2" face="Courier New">meat(beef).</font></p>
<p><font size="2" face="Courier New">dessert(cake).</font></p>
<p><font size="2" face="Courier New">dessert(fruit).</font></p>
<p><font size="2" face="Courier New">little_sum(1, x, y) :-
little_successor(x, y).</font></p>
<p><font size="2" face="Courier New">little_sum(x1, y, z1)
:-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="6%"></td>
<td valign="top" width="94%"><font size="2" face=
"Courier New">little_successor(x, x1),</font>
<p><font size="2" face="Courier New">little_sum(x, y,
z),</font></p>
<p><font size="2" face="Courier New">little_successor(z,
z1).</font></p>
</td>
</tr>
</table>
<p><font size="2" face=
"Courier New">little_successor(1,2).</font></p>
<p><font size="2" face=
"Courier New">little_successor(2,3).</font></p>
<p><font size="2" face=
"Courier New">little_successor(3,4).</font></p>
<p><font size="2" face=
"Courier New">little_successor(4,5).</font></p>
<p><font size="2" face=
"Courier New">little_successor(5,6).</font></p>
<p><font size="2" face=
"Courier New">little_successor(6,7).</font></p>
<p><font size="2" face=
"Courier New">little_successor(7,8).</font></p>
<p><font size="2" face=
"Courier New">little_successor(8,9).</font></p>
<p><font size="2" face="Courier New">light_meal(a, m, d)
:-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="6%"></td>
<td valign="top" width="94%"><font size="2" face=
"Courier New">meal(a, m, d),</font>
<p><font size="2" face="Courier New">units(a, x),</font></p>
<p><font size="2" face="Courier New">units(m, y),</font></p>
<p><font size="2" face="Courier New">little_sum(x, y,
u),</font></p>
<p><font size="2" face="Courier New">units(d, z),</font></p>
<p><font size="2" face="Courier New">little_sum(z, u,
v).</font></p>
</td>
</tr>
</table>
<p><font size="2" face="Courier New">units(beef, 3).</font></p>
<p><font size="2" face="Courier New">units(fruit, 1).</font></p>
<p><font size="2" face="Courier New">units(cake, 5).</font></p>
<p><font size="2" face="Courier New">units(pate, 6).</font></p>
<p><font size="2" face="Courier New">units(pork, 7).</font></p>
<p><font size="2" face="Courier New">units(radishes, 1).</font></p>
<p><font size="2" face="Courier New">units(sole, 2).</font></p>
<p><font size="2" face="Courier New">units(tuna, 4).</font></p>
<p><font face="Garamond">Once the edition task terminated, the user
should compile the program by pressing the button <img src=
"compile.png">(or activating the menu action "Build/Compile"). At
this time, the user can save the program (both the text format with
the extension .prlg and the object format with the extension .obj)
and/or activates the Console pane to ask questions.</font></p>
<p><font face="Garamond">Let us ask one question :</font></p>
<p><font size="2" face="Courier New">?- light_meal(a, m,
d).</font></p>
<p><font size="2" face="Courier New">{a = radishes, m = sole, d =
cake}</font></p>
<p><font size="2" face="Courier New">{a = radishes, m = sole, d =
fruit}</font></p>
<p><font size="2" face="Courier New">{a = radishes, m = tuna, d =
fruit}</font></p>
<p><font size="2" face="Courier New">{a = radishes, m = pork, d =
fruit}</font></p>
<p><font size="2" face="Courier New">{a = radishes, m = beef, d =
cake}</font></p>
<p><font size="2" face="Courier New">{a = radishes, m = beef, d =
fruit}</font></p>
<p><font size="2" face="Courier New">{a = pate, m = sole, d =
fruit}</font></p>
<p><font face="Garamond">Next time, when the file is opened and
compiled directly; without any modification, the system will not
recompile it again, it will rather load the object file. But if the
text file is modified, the user should recompile and save
it.</font></p>
<p>&nbsp;</p>
<p><big><big><strong>9. <a name=
"Specialization"></a></strong><font face=
"Garamond"><b>Specialization (Generalization)
rules</b></font></big></big></p>
<p><font face="Garamond">Before considering in detail
<em>conceptual graphs</em> (CG), we will introduce two related
notions : <strong><em>concept types hierarchy</em></strong>
and<strong><em>instantiation</em></strong>. The two constitute the
<em><strong>support</strong></em> for the manipulation of CGs.
Indeed, as introduced later, CG unification and the other CG
operations make use of these notions. Figure 6 gives the Prolog+CG
primitives for support and CGs&nbsp; manipulation.</font></p>
<p align="center"><img src="EnvPrimHierCG.png" alt=
"EnvPrimHierCG.png (15980 octets)"></p>
<p align="center"><strong>Figure 6 :</strong> Prolog+CG primitives
for support and CG manipulation</p>
<p><font face="Garamond"><strong>Concept types hierarchy</strong>
describes the generalization/specialization relation between the
concept types used in the CGs. It encodes the famous "IsA"
relation, used in many semantic network formalisms. In PROLOG+CG, a
concept type hierarchy is defined as a set of
<strong><i>specialization rules</i></strong>. A specialization rule
describes the immediate subtypes Type1, Type2, &hellip;, TypeN of a
type Type. It has the following form :</font></p>
<p><font face="Courier New" size="3">Type &gt; Type1, Type2,
&hellip;, TypeN.</font></p>
<p><font face="Garamond" size="3"><strong>Example
:</strong></font></p>
<p><small><font face="Courier New">Universal &gt; Person, Animal,
Action, Situation, Object, AbstractEntity, Attribute.<br>
Person &gt; Man, Woman.<br>
Man &gt; Boy, Employee.<br>
Woman &gt; Girl, Employee.<br>
Employee &gt; Supervisor.<br>
Action &gt; Drive, Love, Break, Rent, Begin, Press, Look.<br>
Object &gt; Vehicle, Machine, Key, Keyboard, Finger.<br>
AbstractEntity &gt; Society, Session, Years, Proposition.<br>
Vehicle &gt; Car, Truck.<br>
Attribute &gt; Fast, Color, Expensive, Big.</font></small></p>
<p><font face="Garamond"><strong>Operations on the concept types
hierarchy :</strong> Currently, PROLOG+CG providesthe following
primitive operationson concept types hierarchy :</font></p>
<ul>
<li><font face="Garamond"><strong><font size="3">isSubType(Type1,
Type2) :</font></strong> checks if a type Type1 is a subtype of a
type Type2.</font></li>
<li><font face="Garamond"><strong><font size=
"3">immediateSubTypes(Type, L) :</font></strong> returns in the
list L all the immediate subtypes of a type Type.</font></li>
<li><font face="Garamond"><strong><font size="3">subTypes(Type, L)
:</font></strong> returns in the list L all the subtypes of a type
Type. The types are given in the breadth-first order.</font></li>
<li><font face="Garamond"><strong><font size="3">isSuperType(Type1,
Type2) :</font></strong> checks if a type Type1 is a super-type of
a type Type2.</font></li>
<li><font face="Garamond"><strong><font size=
"3">immediateSuperTypes(Type, L) :</font></strong> returns in the
list L all the immediate super-types of a type Type.</font></li>
<li><font face="Garamond"><strong><font size="3">superTypes(Type,
L) :</font></strong> returns in the list L all the super-types of a
type Type. The types are given in the breadth-first
order.</font></li>
<li><font face="Garamond"><strong><font size=
"3">maxComSubType(Type1, Type2, T) :</font></strong> gives in T the
maximum common subtype of the types Type1 and Type2.</font></li>
<li><font face="Garamond"><strong><font size=
"3">minComSuperType(Type1, Type2, T) :</font></strong> gives in T
the minimum common super-type of the types Type1 and
Type2.</font></li>
</ul>
<p><font face="Garamond"><strong>Example :</strong></font></p>
<p><font face="Courier New"><small>?- isSubType(Supervisor,
Person).<br>
<br>
{}<br>
<br>
?-isSubtype(Supervisor, Girl).<br>
<br>
no.<br>
<br>
?-immediateSubTypes(Action, L).<br>
<br>
{L = (Drive, Love, Break, Rent, Begin, Press, Look)}<br>
<br>
?-subTypes(Person, L).<br>
<br>
{L = (Man, Woman, Boy, Employee, Girl, Supervisor)}<br>
<br>
?-isSuperType(Person, Supervisor).<br>
<br>
{}<br>
<br>
?-immediateSuperTypes(Employee, L).<br>
<br>
{L = (Man, Woman)}<br>
<br>
?-superTypes(Employee, L).<br>
<br>
{L = (Man, Woman, Person, Universal)}<br>
<br>
?- maxComSubType(Man, Woman, x).<br>
<br>
{x = Employee}<br>
<br>
?-maxComSubType(Person, Employee, x).<br>
<br>
{x = Employee}<br>
<br>
?-minComSuperType(Supervisor, Boy, x).<br>
<br>
{x = Man}</small></font></p>
<p>&nbsp;</p>
<p><big><big><font face="Garamond"><b>10. <a name=
"Instantiation"></a>Instantiation rules</b></font></big></big></p>
<p><font face="Garamond">The instantiation relation relates an
instance to its type. In PROLOG+CG, <strong>instances of a
type</strong> are described with an <strong><i>instantiation
rule</i></strong> :</font></p>
<p><font face="Courier New" size="3">Type = Inst1, Inst2, &hellip;,
InstN.</font></p>
<p><font face="Garamond">Instantiation rules are specified as a
complement to the specialization rules which describe the concept
type hierarchy.</font></p>
<p><font face="Garamond"><strong>Example&nbsp; (we assume the
concept type hierarchy introduced in Section 9)
:</strong></font></p>
<p><font face="Courier New"><small>Boy = John, Bob, Sam, Andre.<br>
Girl = Sue, Mary.<br>
Color = red.<br>
Machine = res23.<br>
Years = four.<br>
Key = enter.</small></font></p>
<p><strong>Operations on instances :</strong> PROLOG+CG provides
two operations on type instances (figure 6) :</p>
<ul>
<li><font face="Garamond"><strong><font size=
"3">isInstanceOf(Referent, Type) :</font></strong> checks if the
referent Referent is an instance of a type Type.</font></li>
<li><font face="Garamond"><strong><font size=
"3">addInstance(Referent, Type) :</font></strong> adds Referent as
a new instance in the instances declaration of the type
Type.</font></li>
</ul>
<p><strong><font face="Garamond">Example :</font></strong></p>
<p><font face="Courier New"><small>?- isInstance(Sue, Girl).<br>
<br>
{}<br>
<br>
?-isInstance(Sue, Person).<br>
<br>
{}<br>
<br>
?-isInstance(Sue, Boy).<br>
<br>
no.<br>
<br>
?-isInstance(Karl, Boy).<br>
<br>
no.<br>
<br>
?-addInstance(Karl, Boy).<br>
<br>
{}</small></font></p>
<p><font face="Courier New"><small>?- addInstance(Emp01,
Employee).<br>
<br>
{}</small></font></p>
<p><font face="Garamond">Note that following the two above
operations, the instantiation rule for the type "Boy" is modified
and a new instantiation rule is added for the type "Employee"
:</font></p>
<p><font face="Courier New"><small>Boy = John, Bob, Sam, Andre,
Karl.<br>
Girl = Sue, Mary.<br>
Color = red.<br>
Machine = res23.<br>
Years = four.<br>
Key = enter.<br>
Employee = Emp01.<br></small></font></p>
<p><font face="Garamond">(continue ...)</font><font face=
"Courier New"><small><br>
?-isInstance(Karl, Boy).<br>
<br>
{}<br>
<br>
?- isInstance(Karl, Person).<br>
<br>
{}<br>
<br>
?-</small></font></p>
<p>&nbsp;</p>
<p><big><big><font face="Garamond"><b>11. <a name=
"CG"></a>Conceptual Graph (CG)</b></font></big></big></p>
<p><font face="Garamond">As noted earlier, a composed data in
PROLOG+CG can be a term, a list, a
<strong><em>concept</em></strong> or a <i><strong>conceptual graph
(CG)</strong>.</i></font></p>
<p align="justify"><font face="Garamond"><b>CG.</b> A conceptual
graph (CG), in Prolog+CG, is a graph of nodes that represent
<em>concepts</em> and that are related by <em>conceptual
relations</em>. Only binary relations are considered (this
constraint is for simplicity and practical purpose
only).</font></p>
<p align="justify"><em><strong>Remark :</strong></em> Prolog+CG
provides a large flexibility in the use of variables inside CG : a
variable can stand for a whole CG, a whole concept (like :
[Man]-agnt-&gt;X ; X is a variable), a relation (like :
[Man]-R-&gt;[Eat] ; R is a variable), a concept type or a concept
referent (like : [A : B]-agnt-&gt;[Eat] ; A and B are variables).
Such a flexible use of variables enhances the expressive power of
the language, according to CG manipulation.</p>
<p align="justify"><b>Concept.</b> A concept is composed of a type,
an optional referent and an optional description. A concept type
can be a variable or an identifier that refers to a type defined in
the concept type hierarchy. A concept referent can be a variable,
an instance (an identifier or a string) declared in instances
declaration rules, a set of instances, a co-referent (represented
by a variable) or a multi-referent. A concept description is any
Prolog+CG data : an elementary data like an integer, a real, a
boolean, an identifier, a string or a composed data like a list, a
term, a concept or a CG.</p>
<p align="justify">A multi-referent has the form "*Number" and it
is only used in the linear notation to identify all occurrences of
a concept. A multi-referent is not represented in the internal
representation of the concept. Examples are given below.</p>
<p align="justify">&nbsp;</p>
<p><font face="Garamond"><b>Concept and CG Linear
Notation</b></font></p>
<p><font face="Garamond">The linear notation used in PROLOG+CG to
express CG is similar to the notation introduced first by <a href=
"http://www.jfsowa.com/">Sowa</a>. As introduced above, a concept
has tree fields surrounded by brackets.</font></p>
<p><font face="Garamond"><strong>Examples of concepts
:</strong></font></p>
<p><font size="2" face="Courier New">[Man], [Man : John],</font>
<small><font face="Courier New">[Man : {John, Carl, Henry}], [Cat :
x], [Human : *1], [Integer = 25], [List = (1, 2,
3)],</font></small> <font size="2" face="Courier New">[Date
:CurrentDate = (04,01,2000)]</font><font face=
"Courier New"><font size="2">,</font> <small>[Term = papa(x,
Hicham)],&nbsp;&nbsp;&nbsp; [Proposition :propHenry&nbsp; = [Man :
Carl]&lt;-agnt-[Think]-obj-&gt;[Proposition =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</small></font></p>
<p><font face=
"Courier New"><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Man: Carl]-attr-&gt;[Crazy] ] ]</small></font></p>
<p><font face="Garamond">A relation R between two concepts C1 and
C2 can be expressed as follow :</font> <font size="2" face=
"Courier New">[C1]-R-&gt;[C2]</font> <font face="Garamond" size=
"3">; R of C1 is C2, or</font> <font size="2" face=
"Courier New">[C2]&lt;-R-[C1]</font> <font face="Garamond" size=
"3">which is the same.</font></p>
<p>&nbsp;</p>
<p><strong><font face="Garamond">Example of a simple CG
:</font></strong></p>
<p><font size="2" face="Courier New">[Girl :
Fouzia]&lt;-agent-[Walk]</font> <font face="Garamond" size="3">;
agent of Walk is Girl Fouzia.</font></p>
<p><font face="Garamond">If a concept is connected to several
relations, writes the concept, then a dash followed by a sequence
of relations description separated by comma (see the <a href=
"#Appendix">Appendix</a> for the detailed definition of CG
grammar). Also, the CGs given in this manual illustrates several
cases of writing CG.</font></p>
<p>&nbsp;</p>
<p><strong><font face="Garamond">Example of CG - continued
:</font></strong></p>
<p><font face="Courier New"><small>[Extract]-<br>
&nbsp;&nbsp;&nbsp; -agnt-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp; -obj-&gt;[Text],<br>
&nbsp;&nbsp;&nbsp; -target-&gt;[Book].</small></font></p>
<p><font face="Garamond"><em><strong>The role of the hyphen "-",
the comma "," and the semi-colon ";" :</strong></em> &nbsp; if a
concept (like [Extract]) has several branchs connected to it, then
write the "-" after the concept, write the branchs using "," to
seperate between them and use at the end the ";" to indicate the
end of the specification of the branchs. In this sense, the branchs
of a concept are enclosed by two delimiters : "-" and ";" and they
are separated by the delimiter ",". Note that the delimiter ";" is
optional if we are at the end of the CG, like the example above.Of
course, a concept at the end of a relation can be connected itself
to other relations and so on, forming a tree (and a graph as
described below). This case is illustrated by the following example
:</font></p>
<p><strong><font face="Garamond">Example :</font></strong></p>
<p><font size="2" face="Courier New">[Work]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="515">
<tr>
<td valign="top" width="6%"></td>
<td valign="top" colspan="2" width="37%"><font size="2" face=
"Courier New">-agnt-&gt;[Person: Jane]-</font></td>
<td valign="top" width="57%"></td>
</tr>
<tr>
<td valign="top" width="6%" height="39"></td>
<td valign="top" width="29%" height="39"></td>
<td valign="top" colspan="2" width="65%" height="39"><font size="2"
face="Courier New">-ageOf-&gt;[Age = 30],</font>
<p><font size="2" face="Courier New">&lt;-poss-[House :
*1];,</font></p>
</td>
</tr>
<tr>
<td valign="top" width="6%" height="39"></td>
<td valign="top" colspan="2" width="37%" height="39"><font size="2"
face="Courier New">-near-&gt;[House : *1].</font></td>
<td valign="top" width="57%" height="39"></td>
</tr>
</table>
<p><font face="Garamond">In the example above, the delimiter ";" is
used to specify the end of the specification of the branchs of
[Person : Jane] and the delimiter "," that follows ";" is used to
separate between the two branchs of [Work].&nbsp;</font></p>
<p><font face="Garamond">Finally, note that the tabulation and
carriage-return are used only for "pretty-print"; they are not
considered in the analysis of the notation.</font></p>
<p><font face="Garamond">A linear formulation of any graph (and
hence, of a CG) provides in general a way to specify several
occurrences of the same node (the same concept for CG). In
PROLOG+CG, referent and/or multi-referent is used for this end. In
the above example, the multi-referent "*1" is used to specify that
the two concepts [House : *1] and [House : *1] are in fact two
occurrences of the same concept.</font></p>
<p><font face="Garamond">Relations that are connected to a concept
can be specified as relations connected to the occurrences of the
same concept.</font></p>
<p><strong><font face="Garamond">Example :</font></strong></p>
<p><font face="Courier New"><small>[Extract]-<br>
&nbsp;&nbsp;&nbsp; -agnt-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp; -obj-&gt;[Inanimate : *1]-matr-&gt;[Wood],<br>
&nbsp;&nbsp;&nbsp; -manr-&gt;[Strong],<br>
&nbsp;&nbsp;&nbsp; -target-&gt;[Inanimate]-on-&gt;[Inanimate :
*1]-priceOf-&gt;[Expensive].</small></font></p>
<p><strong><font face="Garamond">Example of compound CG
:</font></strong></p>
<p><font face=
"Courier New"><small>[Person]&lt;-agnt-[Perform]-obj-&gt;[Action =
[Eat]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Walnut = wal2]-part-&gt;[Shell:myShell = toto],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-instr-&gt;[Spoon]-matr-&gt;[Shell : myShell]
]-instr-&gt;[Roulette].</small></font></p>
<p><font face="Garamond">Maybe a better formulation is as follows
:</font></p>
<p><font face="Courier New"><small>[Action = [Eat]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Walnut = wal2]-part-&gt;[Shell : myShell = toto],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-instr-&gt;[Spoon]-matr-&gt;[Shell : myShell]<br>
]&lt;-obj-[Perform]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-instr-&gt;[Roulette].</small></font></p>
<p><font face="Garamond">Note that the two concepts</font>
<font size="2" face="Courier New">[Shell : myShell = toto]</font>
<font face="Garamond">and</font> <font size="2" face=
"Courier New">[Shell : myShell]</font> <font face="Garamond">are
the same. They are identified by the referent (</font><font size=
"2" face="Courier New">myShell</font><font face="Garamond">). Thus,
when the concept has a specific referent, this later can be used
(instead of a multi-referent) to specify the identity of several
occurrences of the same concept.</font></p>
<p>&nbsp;</p>
<p><big><font face=
"Garamond"><strong>Co-references</strong></font></big></p>
<p>A <em><strong>Co-reference</strong></em> is represented with a
variable. An example will illustrate this important notion :
<small><font face="Courier New"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Man : x]&lt;-agnt-[Begin]-srce-&gt;[Proposition =
[Person]&lt;-pat-[Look]-dest-&gt;[Person : x] ]</font></small></p>
<p><font face="Garamond">The variable x plays a role of a
co-reference between the two concepts [Man : x] and [Person : x].
Thus, the two concepts refere to the same entity.</font></p>
<p><font face="Garamond">With the above illustrations concerning CG
notation, the user can combine them in order to formulate any
CG.</font></p>
<p><font face="Garamond"><strong>The use of CG in
PROLOG+CG</strong> : In PROLOG+CG, CG is a basic data structure,
like a term or a list. CG can be an argument of a term, an element
in a list, a value of a concept, the head of a rule (or a fact) or
a goal in the tail of a rule.</font></p>
<p>&nbsp;</p>
<p><big><big><font face="Garamond"><b>12. <a name=
"Sample2"></a>Samples II</b></font></big></big></p>
<p><font face="Garamond">To illustrate the use of CG in PROLOG+CG,
we give in this section two programs. The first has been proposed
first by Fargues et al. [6] (which is a Prolog-based formulation of
an example presented by Sowa, using Peirce Logic). In the first
program, all the goals are formulated as CGs. In general however,
we can have in one rule some goals that are represented by CGs and
others that are represented by terms. The second program
illustrates this point.</font></p>
<p><font face="Garamond"><strong>Program 1 (it can be found in
Samples/Citizen.prlg)</strong> :</font></p>
<p><font size="2" face="Courier New">Universal &gt; PERSON, BORN,
NATURALIZE, COUNTRY.</font></p>
<p><font size="2" face="Courier New">PERSON &gt; CITIZEN,
GIRL.</font></p>
<p><font size="2" face="Courier New">GIRL = "Dorothy".</font></p>
<p><font size="2" face="Courier New">PERSON = "Tinman".</font></p>
<p><font size="2" face="Courier New">COUNTRY = "Oz".</font></p>
<p><font size="2" face="Courier New">[CITIZEN :
x]&lt;-MEMB-[COUNTRY : "Oz"] :-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="7%"></td>
<td valign="top" width="93%"><font size="2" face=
"Courier New">[PERSON: x]&lt;-AGNT-[BORN]-LOC-&gt;[COUNTRY :
"Oz"].</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">[CITIZEN :
x]&lt;-MEMB-[COUNTRY : "Oz"] :-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="7%"></td>
<td valign="top" width="93%"><font size="2" face=
"Courier New">[PERSON: x]&lt;-CHLD-[PERSON: y],</font>
<p><font size="2" face="Courier New">[CITIZEN :
y]&lt;-MEMB-[COUNTRY : "Oz"].</font></p>
</td>
</tr>
</table>
<p><font size="2" face="Courier New">[CITIZEN :
x]&lt;-MEMB-[COUNTRY : "Oz"] :-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="7%"></td>
<td valign="top" width="93%"><font size="2" face=
"Courier New">[PERSON : x]&lt;-RCPT-[NATURALIZE]-LOC-&gt;[COUNTRY :
"Oz"].</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">[PERSON :
"Tinman"]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="7%"></td>
<td valign="top" width="93%"><font size="2" face=
"Courier New">-CHLD-&gt;[GIRL : "Dorothy"],</font>
<p><font size="2" face=
"Courier New">&lt;-AGNT-[BORN]-LOC-&gt;[COUNTRY : "Oz"].</font></p>
</td>
</tr>
</table>
<p><font face="Garamond">Let us ask some requests :</font></p>
<p><font size="2" face="Courier New">?- [CITIZEN :
x]&lt;-MEMB-[COUNTRY : y].</font></p>
<p><font size="2" face="Courier New">{x = "Tinman", y =
"Oz"}.</font></p>
<p><font size="2" face="Courier New">?- [CITIZEN :
"Dorothy"]&lt;-MEMB-[COUNTRY : "Oz"].</font></p>
<p><font size="2" face="Courier New">no.</font></p>
<p>&nbsp;</p>
<p><font face="Garamond"><strong>Program 2 (it can be found in
Samples/GoodSister.prlg) :</strong></font></p>
<p><font size="2" face="Courier New">Universal &gt; Person, Action,
Object, Attribute.</font></p>
<p><font size="2" face="Courier New">Object &gt; House, Restaurant,
Walnut, Shell, Spoon.</font></p>
<p><font size="2" face="Courier New">Attribute &gt; Classical, Age,
Easily.</font></p>
<p><font size="2" face="Courier New">Person &gt; Man,
Woman.</font></p>
<p><font size="2" face="Courier New">Action &gt; Perform, Go, Work,
Buy, Eat, Search.</font></p>
<p><font size="2" face="Courier New">Man = Jo, Mark.</font></p>
<p><font size="2" face="Courier New">Woman = Mary, Jane.</font></p>
<p><font size="2" face="Courier New">// Prolog+CG rules. Notes that
a goal can be a term or a CG.</font></p>
<p><font size="2" face="Courier New">// x, w and a are
variables.</font></p>
<p><font size="2" face="Courier New">goodSister(x) :-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="7%"></td>
<td valign="top" width="93%"><font size="2" face=
"Courier New">employee(x),</font>
<p><font size="2" face="Courier New">[Woman :
x]-attr-&gt;[Classical].</font></p>
</td>
</tr>
</table>
<p><font size="2" face="Courier New">[Woman :
w]-attr-&gt;[Classical] :-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="7%"></td>
<td valign="top" colspan="2" width="93%"><font size="2" face=
"Courier New">[Work]-</font></td>
</tr>
<tr>
<td valign="top" width="7%"></td>
<td valign="top" width="5%"></td>
<td valign="top" width="88%"><font size="2" face=
"Courier New">-near-&gt;[House]-poss-&gt;[Woman : w]-ageOf-&gt;[Age
= a],</font>
<p><font size="2" face="Courier New">-agnt-&gt;[Woman :
w],</font></p>
</td>
</tr>
<tr>
<td valign="top" width="7%"></td>
<td valign="top" colspan="2" width="93%"><font size="2" face=
"Courier New">inf(a, 40).</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">// *1 is a
multi-referent.</font></p>
<p><font size="2" face="Courier New">[Work]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="4%"></td>
<td valign="top" colspan="2" width="35%"><font size="2" face=
"Courier New">-agnt-&gt;[Person : Jane]-</font></td>
<td valign="top" width="61%"></td>
</tr>
<tr>
<td valign="top" width="4%"></td>
<td valign="top" width="29%"></td>
<td valign="top" colspan="2" width="67%"><font size="2" face=
"Courier New">-ageOf-&gt;[Age = 30],</font>
<p><font size="2" face="Courier New">&lt;-poss-[House :
*1]&lt;-nearOf-[Restaurant];,</font></p>
</td>
</tr>
<tr>
<td valign="top" width="4%"></td>
<td valign="top" colspan="3" width="96%"><font size="2" face=
"Courier New">-near-&gt;[House : *1].</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">employee(Mary).</font></p>
<p><font size="2" face="Courier New">employee(Jane).</font></p>
<p><font size="2" face="Courier New">// An example of compound
CG</font></p>
<p><font size="2" face=
"Courier New">[Person]&lt;-agnt-[Perform]-obj-&gt;</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="597">
<tr>
<td valign="top" width="12"></td>
<td valign="top" colspan="2" width="310"><font size="2" face=
"Courier New">[Action = [Eat]-</font></td>
<td valign="top" width="251"></td>
</tr>
<tr>
<td valign="top" width="12"></td>
<td valign="top" width="1"></td>
<td valign="top" colspan="2" width="1037"><font size="2" face=
"Courier New">-obj-&gt;[Walnut=wal2]-part-&gt;[Shell:myShell =
toto],</font>
<p><font size="2" face=
"Courier New">-instr-&gt;[Spoon]-matr-&gt;[Shell :
myShell]</font></p>
</td>
</tr>
<tr>
<td valign="top" width="12"></td>
<td valign="top" colspan="2" width="310"><font size="2" face=
"Courier New">]-manr-&gt;[Easily].</font></td>
<td valign="top" width="251"></td>
</tr>
</table>
<p><font size="2" face="Courier New">sense("extract",
[Search]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="29%"></td>
<td valign="top" width="71%"><font size="2" face=
"Courier New">-agnt-&gt;[Person],</font>
<p><font size="2" face="Courier New">-from-&gt;[Book],</font></p>
<p><font size="2" face=
"Courier New">-obj-&gt;[Information]).</font></p>
</td>
</tr>
</table>
<p><font size="2" face="Courier New">sense("classical woman",
[Woman]-attr-&gt;[Classical]).</font></p>
<p>&nbsp;</p>
<p><font face="Garamond">Let us consider now some questions
:</font></p>
<p><font size="2" face="Courier New">?- goodSister(x).</font></p>
<p><font size="2" face="Courier New">{x = Jane}</font></p>
<p><font size="2" face="Courier New">?-
goodSister(Mary).</font></p>
<p><font size="2" face="Courier New">no.</font></p>
<p><font size="2" face="Courier New">?- [Woman :
x]-attr-&gt;[Classical].</font></p>
<p><font size="2" face="Courier New">{x = Jane}</font></p>
<p>&nbsp;</p>
<p><font face="Garamond" size="3">The next two requests illustrate
how the compound CG are naturally expressed and manipulated in
PROLOG+CG (like simple CG). Note that an embedded CG is considered
in PROLOG+CG as a value of the concept (not as a
referent).</font></p>
<p><font size="2" face="Courier New">?-
[Man]&lt;-agnt-[Perform]-obj-&gt;[Action =
[Eat]-obj-&gt;[Walnut]-part-&gt;[Shell : x] ].</font></p>
<p><font size="2" face="Courier New">{x = myShell}</font></p>
<p><font size="2" face="Courier New">?-
[Man]&lt;-agnt-[Perform]-obj-&gt;[Action = x].</font></p>
<p><font size="2" face="Courier New">{x = [Eat]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="9%"></td>
<td valign="top" colspan="2" width="91%"><font size="2" face=
"Courier New">-obj-&gt;[Walnut = wal2]-part-&gt;</font></td>
</tr>
<tr>
<td valign="top" width="9%"></td>
<td valign="top" width="25%"></td>
<td valign="top" width="66%"><font size="2" face=
"Courier New">[Shell:myShell = toto]&lt;-matr-[Spoon :
*1],</font></td>
</tr>
<tr>
<td valign="top" width="9%"></td>
<td valign="top" colspan="2" width="91%"><font size="2" face=
"Courier New">-instr-&gt;[Spoon : *1]}</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">?- sense("extract",
g).</font></p>
<p><font size="2" face="Courier New">{g = [Search]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="11%"></td>
<td valign="top" width="89%"><font size="2" face=
"Courier New">-agnt-&gt;[Person],</font>
<p><font size="2" face="Courier New">-from-&gt;[Book],</font></p>
<p><font size="2" face=
"Courier New">-obj-&gt;[Information]}</font></p>
</td>
</tr>
</table>
<p><font face="Garamond" size="3">In the next request, the variable
x stand for the concept type. Thus we can reason and manipulate all
the fields of a&nbsp; concept (the type, the referent and the
value).</font></p>
<p><font size="2" face="Courier New">?- sense("extract",
[x]&lt;-obj-[Action]-agnt-&gt;[Person]).</font></p>
<p><font size="2" face="Courier New">{x = Information}</font></p>
<p><font size="2" face="Courier New">?- sense("extract",
[x]&lt;-obj-[Work]-agnt-&gt;[Person]).</font></p>
<p><font size="2" face="Courier New">no.</font></p>
<p><font face="Garamond">The following request is interesting : the
second goal is a variable that will be unified, after the
satisfaction of the first goal, to a CG. So the request is to
search the CG associated to "classical woman" and then try to solve
it (as the next goal of the request).</font></p>
<p><font size="2" face="Courier New">?- sense("classical woman",
g), g.</font></p>
<p><font size="2" face="Courier New">{g =
[Woman]-attr-&gt;[Classical]}</font></p>
<p>&nbsp;</p>
<p><big><big><strong>13. <a name="CGoperations"></a>CG
operations</strong></big></big></p>
<p>Actually, PROLOG+CG provides the following operations on CG, for
both simple and compound CG with sets and co-references (Figure 6)
:</p>
<ul>
<li><strong>concOfCG(c, g) :</strong> check if c is a concept of
the CG g. Concept unification is used to search for such a concept.
The primitive "concOfCG/2" is non-deterministic : it searchs by
default for all the concepts in the CG g that could unify the
concept c which could be totally determined, partially specified
(the concept type or referent is a variable) or non-specified (a
variable). If c is a free variable then the primitive, with the
backtrack, will return all the concepts of the CG g.</li>
<li><strong>branchOfCG(b, g) :</strong> check if the branch b (a
branch is two concepts connected by a relation) is a branch of the
CG g. The primitive "branchOfCG/2" is non-deterministic : it
searchs by default for all the branches in the CG g that could
unify the branch b which could be totally determined, partially
specified or non-specified (a variable). If b is a free variable
then the primitive, with the backtrack, will return all the
branches of the CG g.</li>
<li><strong>maximalJoin(g1, g2, g3)</strong> : returns in g3 the
maximal join of the two CG g1 and g2. maximalJoin joins in g3 any
information contained in g1 and g2. The join is guided of course by
the matching of the two graphs g1 and g2.</li>
<li><strong>generalize(g1, g2, g3)</strong> : returns in g3 the
generalization of the two CG g1 and g2. generalize puts in g3 the
common information found in g1 and g2. Again, the generalize
operation is guided by the matching of the two CG.</li>
<li><strong>subsume(g1, g2)</strong> : checks that g1 subsumes g2 ;
checks that g1 is more general than g2. subsume checks that the
information contained in g1 is more general than the information
contained in g2.</li>
<li><strong>subsume(g1, g2, g3)</strong> : checks that g1 subsumes
g2 and return in g3 the image of g1 in g2 (the sub-graph of g2 that
is ismorph to g1).</li>
</ul>
<p>These operations are provided also with entry points which are
very usefull in natural language processing, as illustrated in
section 14 (sample III).</p>
<p>In the next version of PROLOG+CG, other CG operations will be
added : <em>IsCanonic</em>, <em>Expand Concept</em>,
<em>Contract</em> and <em>Analog</em>.</p>
<p>&nbsp;</p>
<p><strong>Examples of calling CG operations</strong> <font face=
"Garamond"><strong>(it can be found in
Samples/ExpleCGs.prlg)</strong></font> :</p>
<p><font face="Garamond" size="3">To facilitate the demo, the
program contains already the specification of some CGs.</font></p>
<p><img src="CGOpersPrt1.png" alt=
"CGOpersPrt1.png (7166 octets)"></p>
<p><img src="CGOpersPrt2.png" alt=
"CGOpersPrt2.png (8471 octets)"></p>
<p>&nbsp;</p>
<p><font face="Garamond" size="3">Let us asks some requests
:</font></p>
<ul>
<li><font size="3"><strong>Examples of calling the primitive
concOfCG/2</strong></font></li>
</ul>
<p><font size="2"><font face="Courier New">?- concOfCG([Drive],
[Drive]-obj-&gt;[Car]).</font></font></p>
<p><font face="Courier New">{}</font></p>
<p><font face="Courier New">?- concOfCG(c, [Man :
John]-child-&gt;[Boy : Bob]&lt;-agnt-[Love]-obj-&gt;[Girl :
Mary]).</font></p>
<p><font face="Courier New">{c = [Man : John]}</font></p>
<p><font face="Courier New">{c = [Boy : Bob]}</font></p>
<p><font face="Courier New">{c = [Love]}</font></p>
<p><font face="Courier New">{c = [Girl : Mary]}</font></p>
<p><font face="Courier New">?- concOfCG([Person : x], [Man :
John]-child-&gt;[Boy : Bob]&lt;-agnt-[Love]-obj-&gt;[Girl :
Mary]).</font></p>
<p><font face="Courier New">{x = John}</font></p>
<p><font face="Courier New">{x = Bob}</font></p>
<p><font face="Courier New">{x = Mary}</font></p>
<p><font face="Courier New" size="2">&nbsp;</font></p>
<ul>
<li><font size="3"><strong>Examples of calling the primitive
branchOfCG/2</strong></font>
<ul>
<li><font face="Garamond"><i>Gives the children of the person x
:</i> note that the whole concept (the target of the relation
child) is represented by the variable C.</font></li>
</ul>
</li>
</ul>
<p align="justify"><font size="2"><font face="Courier New">?-
branchOfCG([Person : x]-child-&gt;C, [Man : John]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-child-&gt;[Boy : Bob],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-attr-&gt;[Color :black],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-child-&gt;[Girl : Mary],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;-agnt-[Eat] ).</font></font></p>
<p align="justify"><font face="Courier New">{x = John, C = [Boy :
Bob]}</font></p>
<p align="justify"><font face="Courier New">{x = John, C = [Girl :
Mary]}</font></p>
<p align="justify">&nbsp;</p>
<blockquote>
<ul type="circle">
<li><i><font face="Garamond" size="3">Search the relations that
relate two persons x and y :</font> note that the relation is
represented by a variable.</i></li>
</ul>
</blockquote>
<p align="justify"><font face="Courier New" size="2">?-
branchOfCG([Person : x]-R-&gt;[Person : y], [Man : John]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-child-&gt;[Boy : Bob],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-attr-&gt;[Color :black],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-child-&gt;[Girl : Mary],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;-agnt-[Eat] ).</font></p>
<p align="justify"><font face="Courier New">{x = John, R = child, y
= Bob}</font></p>
<p align="justify"><font face="Courier New">{x = John, R = child, y
= Mary}</font></p>
<p align="justify">&nbsp;</p>
<blockquote>
<ul type="circle">
<li><font face="Garamond" size="4">Gives all the branches of a CG
:</font></li>
</ul>
</blockquote>
<p align="justify"><font face="Courier New" size="2">?-
branchOfCG(b, [Man : John]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-child-&gt;[Boy : Bob],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-attr-&gt;[Color :black],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-child-&gt;[Girl : Mary],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;-agnt-[Eat] ).</font></p>
<p align="justify"><font face="Courier New">{b = [Man :
John]-child-&gt;[Boy : Bob]}</font></p>
<p align="justify"><font face="Courier New">{b = [Man :
John]-attr-&gt;[Color : black]}</font></p>
<p align="justify"><font face="Courier New">{b = [Man :
John]-child-&gt;[Girl : Mary]}</font></p>
<p align="justify"><font face="Courier New">{b =
[Eat]-agnt-&gt;[Man : John]}</font></p>
<p align="justify">&nbsp;</p>
<p align="justify"><font face="Garamond" size="4"><strong>The other
CG operations (unification, subsume, maximalJoin,
generalize)</strong></font></p>
<ul>
<li>
<p align="justify"><b><font face="Garamond" size="4">Unification
operation</font><font face="Garamond"><font size=
"4">:</font></font> eq/2 corresponds to the unification
operation</b></p>
<p align="justify"><font face="Garamond"><b><font size=
"3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eq(Concept c1, Concept c2) and
eq(CG g1, CG g2) :</font></b> </font></p>
<ul>
<li><font face="Garamond"><i><strong>Unification on concepts
:</strong> concepts are considered as Prolog+CG data
structures</i></font></li>
</ul>
</li>
</ul>
<p><font size="2"><font face="Courier New">?- eq([Person : John],
[Man : x]).</font></font></p>
<p><font face="Courier New">{x = John}</font></p>
<p><font face="Courier New">?- eq([Person : John], [Woman :
x]).</font></p>
<p><font face="Courier New">no.</font></p>
<p><font face="Courier New">? member([Person : x], ([Man : John],
[Color : red], [Woman : Mary])).</font></p>
<p><font face="Courier New">{x = John}</font></p>
<p><font face="Courier New">{x = Mary}</font></p>
<p><font face="Garamond" size="2">&nbsp;</font></p>
<blockquote>
<ul type="circle">
<li><font size="3" face="Garamond"><strong>Unification on simple
CGs with sets :</strong> <em>it fails since Andre is not specified
in the set {John, Bob, Sam}.</em></font></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
eq([Person : Andre]&lt;-agnt-[Drive]-obj-&gt;[Vehicle :
myCar],</font></font></p>
<p align="justify"><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Boy : {John, Bob,
Sam}]&lt;-agnt-[Drive]-</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-obj-&gt;[Car
:x],</font></p>
<p align="justify"><font face=
"Courier New">-manr-&gt;[Fast]).</font></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">no.</font></p>
<p align="justify"><font size="2"><font face="Courier New">?-
eq([Person : Bob]&lt;-agnt-[Drive]-obj-&gt;[Vehicle :
myCar],</font></font></p>
<p align="justify"><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Boy : {John, Bob,
Sam}]&lt;-agnt-[Drive]-</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-obj-&gt;[Car
:x],</font></p>
<p align="justify"><font face=
"Courier New">-manr-&gt;[Fast]).</font></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">{x = myCar}</font></p>
<p align="justify">&nbsp;</p>
<blockquote>
<ul type="circle">
<li><font size="3" face="Garamond"><strong>Unification on compound
CGs with co-referents :</strong></font> the unification succeeds
since, apart from the unification of the other components of the
two CGs, the co-reference `x' between [Person : x] and
[Man : x] in the first CG can be unified with the co-reference
`Andre' between [Man : Andre] and [Boy : Andre] in the
second CG. Indeed, the concepts [Person : x]/[Man : x] refer to the
same entity and this is also the case for the concepts [Man :
Andre]/[Boy : Andre].</li>
</ul>
</blockquote>
<p><font face="Garamond" size="2">&nbsp;</font></p>
<p align="justify"><font size="2"><font face="Courier New">?-
eq(<b>[Person : x]</b>&lt;-agnt-[Begin]-srce-&gt;[Proposition =
<b>[Man :
x]</b>&lt;-agnt-[Action]-obj-&gt;[Object]],</font></font></p>
<blockquote>
<p align="justify"><font face="Courier New">[Man :
Andre]&lt;-agnt-[Begin]-</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<pre>
<font face="Courier New" size=
"2">-obj-&gt;[Session],</font><font size="3" face=
"Courier New"> </font>
</pre>
<pre>
<font face=
"Courier New">-srce-&gt;[Proposition = [Boy:Andre]&lt;-agnt-[Press]-obj-&gt; [Key :enter]-part-&gt;[Keyboard]]).</font>
</pre></blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">{x = Andre}</font></p>
<p align="justify">&nbsp;</p>
<blockquote>
<ul type="circle">
<li><font face="Garamond" size="3"><strong>Unification on compound
CGs with co-referents :</strong></font> here, the unification fails
since the co-reference `x' in the first CG can't
be unified.</li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
eq(<b>[Person : x]</b>&lt;-agnt-[Begin]-srce-&gt;[Proposition =
<b>[Man :
x]</b>&lt;-agnt-[Action]-obj-&gt;[Object]],</font></font></p>
<blockquote>
<p align="justify"><font face="Courier New">[Man :
Andre]&lt;-agnt-[Begin]-</font></p>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<pre>
<font face="Courier New" size="3">-obj-&gt;[Session], </font>
</pre>
<pre>
<font face=
"Courier New">-srce-&gt;[Proposition = [Boy :John]&lt;-agnt-[Press]-obj-&gt;[Key:enter]-part-&gt;[Keyboard]]).</font>
</pre></blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">no.</font></p>
<blockquote>
<ul type="circle">
<li><font face="Garamond" size="3"><strong>Unification on compound
CGs with co-referents :</strong></font> here, the unification fails
too since the co-reference `x' in the first CG has no
corresponding co-reference in the second CG.</li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
eq(<b>[Person : x]</b>&lt;-agnt-[Begin]-srce-&gt;[Proposition =
<b>[Man :
x]</b>&lt;-agnt-[Action]-obj-&gt;[Object]],</font></font></p>
<blockquote>
<p align="justify"><font face=
"Courier New">[Man]&lt;-agnt-[Begin]-</font></p>
<blockquote>
<blockquote>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Session],</font></p>
<p align="justify"><font face="Courier New">-srce-&gt;[Proposition
=</font></p>
<p align="justify"><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Boy]&lt;-agnt-[Press]-obj-&gt;[Key :
enter]-part-&gt;[Keyboard]]).</font></p>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">no.</font></p>
<p align="justify">&nbsp;</p>
<ul>
<li><strong><big><font face="Garamond">Subsume
operation</font></big></strong></li>
</ul>
<p><small><font face="Courier New">?-
subsume([Person]-child-&gt;[Person],[Man:John]-child-&gt;[Boy:Bob]&lt;-agnt-[Love]-obj-&gt;[Girl:Mary]).</font></small></p>
<p><font face="Courier New" size="2">{}</font></p>
<p><small><font face="Courier New">?-
subsume([Person]-child-&gt;[Person],</font></small></p>
<p><small><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Man:John]-child-&gt;[Boy:Bob]&lt;-agnt-[Love]-obj-&gt;[Girl:Mary],
g3).</font></small></p>
<p><small><font face="Courier New"><br>
{g3 = [Man :John]-child-&gt;[Boy : Bob]}</font></small></p>
<p>&nbsp;</p>
<blockquote>
<ul type="circle">
<li><font face="Garamond"><i><strong>Subsume on simple CGs with
sets :</strong></i></font></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
subsume([Person]-child-&gt;[Person : {John,
Sam}],</font></font></p>
<p align="justify"><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Man
: John]-child-&gt;[Boy : {Bob, John, Andre,
Sam}]&lt;-agnt-[Love]-obj-&gt;[Girl : Mary]).</font></p>
<p align="justify"><font face="Courier New">{}</font></p>
<blockquote>
<ul type="circle">
<li><font face="Garamond" size="3"><strong>The same request but we
specify the third argument to get the image of the first argument
:</strong></font></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
subsume([Person]-child-&gt;[Person : {John,
Sam}],</font></font></p>
<p align="justify"><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Man :
John]-child-&gt;[Boy : {Bob, John, Andre,
Sam}]&lt;-agnt-[Love]-obj-&gt;[Girl : Mary], g).</font></p>
<p align="justify"><font face="Courier New">{g = [Man :
John]-child-&gt;[Boy : {Bob, John, Andre, Sam}]}</font></p>
<p align="justify">&nbsp;</p>
<blockquote>
<ul type="circle">
<li><strong><font face="Garamond" size="3">Subsume fails since the
set {John, Sam} is not included in the set {Bob, John, Andre}
:</font></strong></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face=
"Courier New">?-subsume([Person]-child-&gt;[Person : {John, Sam}],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></font></p>
<p align="justify"><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Man :
John]-child-&gt;[Boy : {Bob, John,
Andre}]&lt;-agnt-[Love]-obj-&gt;[Girl : Mary]).</font></p>
<p align="justify"><font face="Courier New" size="2">no.</font></p>
<p align="justify">&nbsp;</p>
<blockquote>
<ul type="circle">
<li><font face="Garamond"><i><strong>Subsume on compound CGs
without co-references :</strong></i></font></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
subsume([Person ]&lt;-agnt-[Begin]-srce-&gt;[Proposition =
[Person]&lt;-agnt-[Action]-obj-&gt;[Object]],</font></font></p>
<p align="justify"><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Man]&lt;-agnt-[Begin]-</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Session],</font></p>
<pre>
<font face="Courier New" size="2">-srce-&gt;[Proposition =</font>
</pre></blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<pre>
<font face="Courier New" size=
"2">[Boy]&lt;-agnt-[Press]-obj-&gt;[Key:enter]-part-&gt;[Keyboard]],g).</font>
</pre></blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">{g = [Begin]
-</font></p>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-srce-&gt;[Proposition
= [Press] -</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-obj-&gt;[Key :
enter],</font></p>
<p align="justify"><font face="Courier New">-agnt-&gt;[Boy]
],</font></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face=
"Courier New">-agnt-&gt;[Man]}</font></p>
</blockquote>
</blockquote>
<p align="justify"><font face="Garamond"><i>&nbsp;</i></font></p>
<blockquote>
<ul type="circle">
<li><strong><em>Subsume on compound CGs with co-reference
:</em></strong> <font face="Garamond" size="3">The same request as
the precedent but a co-reference `x' is added in the
first argument. Subsume fails in this case since the co-reference
`x' is not mapped to a co-reference in the second CG :
the first CG doesn't totally subsume the second CG; the
information that the two concepts [Person : x] and [Person : x]
refers to the same entity is not found in the second CG since the
corresponding concepts in the second CG [Man] and [Boy] could refer
to different entities.</font></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
subsume(</font></font></p>
<p align="justify"><font face="Courier New"><b>&nbsp;&nbsp;&nbsp;
[Person :x]</b>&lt;-agnt-[Begin]-srce-&gt;[Proposition =
<b>[Person:x]</b>&lt;-agnt-[Action]-obj-&gt;[Object]],</font></p>
<p align="justify"><font face="Courier New">&nbsp;&nbsp;&nbsp;
[Man]&lt;-agnt-[Begin]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition =
[Boy]&lt;-agnt-[Press]-obj-&gt;[Key:enter]-part-&gt;[Keyboard]],g).</font></p>
<p align="justify"><font face="Courier New">no.</font></p>
<p align="justify">&nbsp;</p>
<blockquote>
<ul type="circle">
<li><font face="Garamond" size="3"><strong>Subsume on compound CGs
with co-reference :</strong></font> The same request as the
precedent but a co-reference `y' is added to the second
CG. Subsume is possible in this case since the constraint imposed
by the co-reference in the first CG is verified by a corresponding
co-reference in the second CG.</li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
subsume(</font></font></p>
<p align="justify"><font face="Courier New"><b>&nbsp;&nbsp;&nbsp;
[Person :x]</b>&lt;-agnt-[Begin]-srce-&gt;[Proposition =
<b>[Person:x]</b>&lt;-agnt-[Action]-obj-&gt;[Object]],</font></p>
<p align="justify"><font face="Courier New"><b>&nbsp;&nbsp;&nbsp;
[Man : y]</b>&lt;-agnt-[Begin]-</font></p>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Session],</font></p>
<p align="justify"><font face="Courier New">-srce-&gt;[Proposition
=</font></p>
</blockquote>
<p align="justify"><font face=
"Courier New"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Boy: y]</b>&lt;-agnt-[Press]-obj-&gt;[Key
:enter]-part-&gt;[Keyboard]], g).</font></p>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">{x = FREE, y = FREE, g
= [Begin] -</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-srce-&gt;[Proposition
= [Press] -</font></p>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-agnt-&gt;<b>[Boy :
y]</b>,</font></p>
<p align="justify"><font face="Courier New">-obj-&gt;[Key :
enter]],</font></p>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">-agnt-&gt;<b>[Man :
y]</b>}</font></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify">&nbsp;</p>
<ul>
<li>
<p align="justify"><big><font face="Garamond"><strong>maximalJoin
operation</strong></font></big></p>
</li>
</ul>
<p><font face="Courier New"><small>?- cg(cg12, g1, g2),
maximalJoin(g1, g2, g3).<br>
{g1 = [Drive] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Car],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person], g2 = [Drive] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-manr-&gt;[Fast],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Boy : John], g3 = [Drive] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Boy : John],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Car],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-manr-&gt;[Fast]}</small></font></p>
<blockquote>
<ul type="circle">
<li><font face="Garamond"><i><strong>MaximalJoin on simple CGs with
sets :</strong></i></font></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
maximalJoin([Person : {Bob,
Andre}]&lt;-agnt-[Drive]-obj-&gt;[Car],</font></font></p>
<p align="justify"><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Boy : {John, Bob, Sam}]&lt;-agnt-[Drive]-manr-&gt;[Fast],
g).</font></p>
<p align="justify"><font face="Courier New">{g = [Drive]
-</font></p>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-agnt-&gt;[Boy : {John,
Bob, Sam, Andre}],</font></p>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Car],</font></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face=
"Courier New">-manr-&gt;[Fast]}</font></p>
</blockquote>
</blockquote>
<p align="justify"><font face="Garamond" size="2">&nbsp;</font></p>
<blockquote>
<ul type="circle">
<li><strong><font face="Garamond" size="3">MaximalJoin on simple
CGs with coercion and set :</font></strong></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
maximalJoin([Person :
Andre]&lt;-agnt-[Drive]-obj-&gt;[Car],</font></font></p>
<p align="justify"><font face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Boy :{John, Bob, Sam}]&lt;-agnt-[Drive]-manr-&gt;[Fast],
g).</font></p>
<p align="justify"><font face="Courier New">{g = [Drive]
-</font></p>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-agnt-&gt;[Boy : {John,
Bob, Sam, Andre}],</font></p>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Car],</font></p>
<p align="justify"><font face=
"Courier New">-manr-&gt;[Fast]}</font></p>
</blockquote>
</blockquote>
<p align="justify"><font face="Garamond" size="1">&nbsp;</font></p>
<blockquote>
<ul type="circle">
<li><strong><font face="Garamond" size="3">Maximal Join failure :
coercion impossible since Mary is not conform to Boy
:</font></strong></li>
</ul>
</blockquote>
<p align="justify"><font size="2" face="Courier New">?-
maximalJoin([Person :
Mary]&lt;-agnt-[Drive]-obj-&gt;[Car],</font></p>
<p align="justify"><font size="2" face=
"Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Boy : {John, Bob, Sam}]&lt;-agnt-[Drive]-manr-&gt;[Fast],
g).</font></p>
<p align="justify"><font size="2"><font face=
"Courier New">no.</font></font></p>
<blockquote>
<ul type="circle">
<li><font face="Garamond" size="3"><i><strong>Maximal join on
compound CGs :</strong></i></font></li>
</ul>
</blockquote>
<p><small><font face="Courier New">?- cg(cg910, g1, g2),
maximalJoin(g1, g2, g3).<br>
{g1 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : John]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : John], g2 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-manr-&gt;[Fast],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Man],</font></small></p>
<p><small><font face="Courier New">g3 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : John],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-manr-&gt;[Fast]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Man : John],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session]}</font></small></p>
<p><font face="Garamond">Concerning the next request, notes that
the maximalJoin of the embeeded graphs :</font></p>
<p><small><font face="Courier New">&nbsp;&nbsp;&nbsp; [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person]</font></small></p>
<p><font face="Garamond">and</font></p>
<p><small><font face="Courier New">&nbsp;&nbsp;&nbsp; [Look] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-dest-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-pat-&gt;[Person]</font></small></p>
<p><font face="Garamond">will discover that the two graphs have
nothing in common except the [Person] concept. Thus, the
maximalJoin will be done around the concept [Person] of the first
graph and one concept [Person] of the second.</font></p>
<p><small><font face="Courier New">?- cg(cg1011, g1, g2),
maximalJoin(g1, g2, g3).<br>
{g1 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person], g2 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Look] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-dest-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-pat-&gt;[Person]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Man],</font></small></p>
<p><small><font face="Courier New">g3 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person]&lt;-pat-[Look]-dest-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Man],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session]}<small><br></small></font></small></p>
<blockquote>
<ul type="circle">
<li><font face="Garamond"><strong>maximalJoin on compound CGs with
co-references</strong></font></li>
</ul>
</blockquote>
<p>To illustrate the interplay between co-references and maximal
join, we will change, in the above program the fact cg(cg1011, ...)
as follows : we add a co-reference, represented by the variable x,
between the two concepts [Person <strong>: x</strong>] and [Person
<strong>: x</strong>] in the first CG.</p>
<p><small><font face="Courier New">cg(cg1011,<br>
&nbsp;&nbsp;&nbsp; [Person <strong>:
x</strong>]&lt;-agnt-[Begin]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Person <strong>: x</strong>]&lt;-agnt-[Press]-obj-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[Key : enter]-part-&gt;[Keyboard] ],<br>
&nbsp;&nbsp;&nbsp; [Man]&lt;-agnt-[Begin]-srce-&gt;[Proposition =
[Person]&lt;-pat-[Look]-dest-&gt;[Person] ]).</font></small></p>
<p>As shown by the following request, the CG g3 that results from
the maximalJoin of the two CG g1 and g2 will contain the above
coreference. In fact, <em><strong>coreference is considered as an
implicit relation</strong></em> between the two concepts. So, in
the maximalJoin, such a relation will remain.</p>
<p><font face="Courier New"><small>?- cg(cg1011, g1, g2),
maximalJoin(g1, g2, g3).<br>
{g1 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : x]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : x],</small></font></p>
<p><font face="Courier New"><small>g2 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Look] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-dest-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-pat-&gt;[Person]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Man],</small></font></p>
<p><font face="Courier New"><small>g3 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : x]&lt;-pat-[Look]-dest-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Man : x],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session]}</small></font></p>
<p>&nbsp;</p>
<p>Now and to illustrate&nbsp; <strong><em>the impact</em></strong>
of <strong><em>co-references on maximal join</em></strong>, we will
change, in the above program the fact cg(cg1011, ...) as follows
:</p>
<p><small><font face="Courier New">cg(cg1011,<br>
&nbsp;&nbsp;&nbsp; [Person <strong>:
x</strong>]&lt;-agnt-[Begin]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Person
<strong>: x</strong>]&lt;-agnt-[Press]-obj-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Key
: enter]-part-&gt;[Keyboard] ],<br>
&nbsp;&nbsp;&nbsp; [Man <strong>:
y</strong>]&lt;-agnt-[Begin]-srce-&gt;[Proposition =
[Person]&lt;-pat-[Look]-dest-&gt;[Person <strong>: y</strong>]
]).</font></small></p>
<p>The variable x is a co-reference between the two concepts
[Person : x] and [Person :x] and the variable y is a co-reference
between the two concepts [Man : y] and [Person : y].</p>
<p>To make the above change effective, we have to recompile the
program and then ask the same request :</p>
<p><small><font face="Courier New">?- cg(cg1011, g1, g2),
maximalJoin(g1, g2, g3).<br>
{g1 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : x]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : x], g2 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Look] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-dest-&gt;[Person : y],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-pat-&gt;[Person]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Man : y],</font></small></p>
<p><small><font face="Courier New">g3 = [Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -srce-&gt;[Proposition =
[Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : x]&lt;-dest-[Look]-pat-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard]],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -agnt-&gt;[Man : x],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session]}</font></small></p>
<p><small><font face="Courier New">?-</font></small></p>
<p><font face="Garamond">If you look at the result g3 and
especially at the embedded graph :</font></p>
<p><small><font face="Courier New">&nbsp;&nbsp;&nbsp; [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -agnt-&gt;[Person
: x]&lt;-dest-[Look]-pat-&gt;[Person],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -obj-&gt;[Key :
enter]-part-&gt;[Keyboard]</font></small></p>
<p><font face="Garamond">you will note that it is different from
the previous one : the maximalJoin between the two initial graphs
has been done around the destination (dest) of [Look], not the
patient. The reason is this : since the concept</font> [Person : x]
in g1 (in the first level of g1) has been joined with the concept
[Man : y] in g2 and since the embedded graphs that contain the
concepts [Person : x] and [Person : y] will be joined, then we must
begin their maximalJoin by joining the concept [Person : x] with
the [Person : y]. Note also that the resulting graph g3 contains
the co-reference x that relates the concept that results from the
join of&nbsp; [Person : x] and [Man : y] with the concept that
results from the join of&nbsp; [Person : y] and [Person : y].</p>
<p>&nbsp;</p>
<ul>
<li><big><font face="Garamond"><strong>Generalize
operation</strong></font></big></li>
</ul>
<p><font face="Courier New"><small><small>?-</small> cg(cg34, g1,
g2), generalize(g1, g2, g3).<br>
{g1 = [Drive] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Car]-chrc-&gt;[Color : red],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Boy : John], g2 = [Drive] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Truck],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-manr-&gt;[Fast],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Girl : Sue], g3 = [Drive] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Vehicle],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person]}</small></font></p>
<blockquote>
<ul type="circle">
<li><font face="Garamond"><i><strong>generalize on simple CGs with
sets :</strong> the case of intersection between
sets</i></font></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
generalize([Person : {John, Sam, Sue,
Mary}]&lt;-agnt-[Drive]-obj-&gt;[Car]-chrc-&gt;[Color :
red],</font></font></p>
<p align="justify"><font face="Courier New">&nbsp;&nbsp;&nbsp;
[Girl : {Sue, Mary, Katy}]&lt;-agnt-[Drive]-</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Truck],</font></p>
<p align="justify"><font face="Courier New">-manr-&gt;[Fast],
g).</font></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">{g = [Drive]
-</font></p>
<blockquote>
<blockquote>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Vehicle],</font></p>
<p align="justify"><font face="Courier New">-agnt-&gt;[Person :
{Sue, Mary}]}</font></p>
</blockquote>
</blockquote>
<p align="justify"><font face="Garamond" size="2">&nbsp;</font></p>
<blockquote>
<ul type="circle">
<li><font face="Garamond" size="3"><strong>Generalize on simple CGs
with sets :</strong> the case of membership of an element to a
set</font></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
generalize([Person : {John, Sam, Sue,
Mary}]&lt;-agnt-[Drive]-obj-&gt;[Car]-chrc-&gt;[Color :
red],</font></font></p>
<p align="justify"><font face="Courier New">&nbsp;&nbsp;&nbsp;
[Girl : Sue]&lt;-agnt-[Drive]-</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Truck],</font></p>
<p align="justify"><font face="Courier New">-manr-&gt;[Fast],
g).</font></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face="Courier New">&nbsp;&nbsp;&nbsp; {g =
[Drive] -</font></p>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Vehicle],</font></p>
<p align="justify"><font face="Courier New">-agnt-&gt;[Person :
Sue]}</font></p>
<p align="justify">&nbsp;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<ul type="circle">
<li><font face="Garamond"><i><strong>generalization of compound CGs
with co-references :</strong></i> </font><font face="Garamond"
size="3">Generalize treats co-references as it does with relations
: in this example, since the co-reference `x' in the
first argument g1 has no corresponding co-reference in the second
argument, then no co-reference is added to the resulted graph
g.</font></li>
</ul>
</blockquote>
<p align="justify"><font size="2"><font face="Courier New">?-
generalize(</font></font></p>
<p align="justify"><font face="Courier New"><b>[Person:
x]</b>&lt;-agnt-[Begin] -</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face=
"Courier New">-obj-&gt;[Session],</font></p>
<p align="justify"><font face="Courier New">-srce-&gt;[Proposition
= [Press] -</font></p>
<blockquote>
<p align="justify"><font face="Courier New">-obj-&gt;[Key :
enter]-part-&gt;[Keyboard],</font></p>
<p align="justify"><font face="Courier New">-agnt-&gt;<b>[Person :
x]</b> ],</font></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify"><font face=
"Courier New">[Man]&lt;-agnt-[Begin]-srce-&gt;[Proposition =
[Boy]&lt;-agnt-[Action]-dest-&gt;[Person] ], g).</font></p>
<p align="justify">&nbsp;</p>
<p align="justify"><font face="Courier New">{x = FREE, g = [Begin]
-</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-srce-&gt;[Proposition
= [Action]-agnt-&gt;[Person]],</font></p>
<p align="justify"><font face=
"Courier New">-agnt-&gt;[Person]}</font></p>
<p align="justify">&nbsp;</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<ul type="circle">
<li>
<p align="justify"><font face="Garamond"><i><strong>Impact of
co-references on generalize :</strong></i> </font><font face=
"Garamond" size="3">In the current definition and implementation of
generalize, we consider the following heuristic about treatment of
co-references : if both the first and the second arguments
(let's call them g1 and g2) contain co-referents, like in
this example (represented by variable `x' and
`y' respectively), and if the generalization of the
first level of the two CGs involves a common generalization of the
two co-references (i.e. generalization of [Person : x] in g1 with
[Man : y] in g2 producing [Person : c01] in the resulting CG g),
and if the context [Proposition : &hellip;] in g1 is being
generalized with the context [Proposition : &hellip;] in g2, then
the generalization of the contain of these two contexts will be
constrained by the generalization of the co-references
`x' and `y' : the concept [Person : x] in
the context embedded in g1 MUST BE generalized with the concept
[Person : y] in the context embedded in g2. The result is the
concept [Person : c01] which is in co-reference with the concept
[Person : c01], the two are concepts of the resulted CG g. Note
that this graph is different from the resulted CG of the precedent
example. As this example shows, with the above heuristic, we
preserve the specific information that the two contexts
[Proposition &hellip;] and [Proposition &hellip;] contains the same
entity, refereed in the first context by [Person : x] and in the
second by [Person : y]. However, we loose other information like
that the two contexts contain the information :
[Action]-agnt-&gt;[Person]. A better solution may be a conjunction
of the two information : [Person : c01] and
[Action]-agnt-&gt;[Person]. Further study is required for the
treatment of co-references by the generalization operation
(depending on the interpretation given to it).</font></p>
</li>
</ul>
</blockquote>
<p align="justify"><font face="Garamond" size="2">&nbsp;</font></p>
<p align="justify"><font size="2"><font face="Courier New">?-
generalize(</font></font></p>
<p align="justify"><font face="Courier New">[Person:
x]&lt;-agnt-[Begin] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Session],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-srce-&gt;[Proposition = [Press] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Key : enter]-part-&gt;[Keyboard],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Person : x] ],</font></p>
<p align="justify"><font face="Courier New"><b>&nbsp;&nbsp;&nbsp;
[Man: y]</b>&lt;-agnt-[Begin]-srce-&gt;[Proposition :
[Boy]&lt;-agnt-[Action]-dest-&gt;<b>[Person : y]</b> ],
g).</font></p>
<p align="justify">&nbsp;</p>
<p align="justify"><font face="Courier New">{x = FREE, y = FREE, g
= [Begin] -</font></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p align="justify"><font face="Courier New">-srce-&gt;[Proposition
: [Person : c01]],</font></p>
<p align="justify"><font face="Courier New">-agnt-&gt;[Person :
c01]}</font></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p align="justify">&nbsp;</p>
<p><big><big><font face="Garamond"><strong><big>14.</big> <a name=
"Sample23"></a>Sample III : Semantic
analyzer</strong></font></big></big></p>
<p><font face="Garamond">This example illsutrates the expressive
power that results from the integration of CG to PROLOG and also
the possibility to manipulate directly CG from a programming
language perspective. For instance, this example shows how
variables can be used to stand for concept type, concept referent,
concept value, for the whole concept or even for a relation. The
example illustrates also how a CG can be constructed by successive
calls to maximal join on other CGs. Finally, it is our hope the
convince the reader that PROLOG+CG is very suited for natural
language processing. See <a href=
"http://www.insea.ac.ma/CGTools/SHRDLUCom.pdf">SHRDHLCom</a> for a
detailed description of the program.</font></p>
<p><font size="2" face="Courier New">Universal &gt; Personne,
Objet, Action, Attribut.</font></p>
<p>Personne &gt; Homme.</p>
<p>Objet &gt; PYRAMIDE, CUBE.</p>
<p>Action &gt; METTRE.</p>
<p>Attribut &gt; TAILLE, COULEUR.</p>
<p>&nbsp;</p>
<p>COULEUR = bleu, rouge.</p>
<p>TAILLE = petite, grand.</p>
<p>Homme = john.</p>
<p>dictionnaire("mets", verbe, METTRE).</p>
<p>dictionnaire("pyramide", nom, PYRAMIDE).</p>
<p>dictionnaire("cube", nom, CUBE).</p>
<p>dictionnaire("petite", adj, tailleDe, TAILLE, petite).</p>
<p>dictionnaire("rouge", adj, couleurDe, COULEUR, rouge).</p>
<p>dictionnaire("grand", adj, tailleDe, TAILLE, grand).</p>
<p>dictionnaire("bleu", adj, couleurDe, COULEUR, bleu).</p>
<p>dictionnaire("sur", prep, sur).</p>
<p>dictionnaire("la", art, x).</p>
<p>dictionnaire("le", art, x).</p>
<p>Verbe((v|P), P, V) :- dictionnaire(v, verbe, V).</p>
<p>Prep((v|P), P, V) :- dictionnaire(v, prep, V).</p>
<p>Art((v|P), P, V) :- dictionnaire(v, art, V), /.</p>
<p>Art(P, P, undefined).</p>
<p>Nom((v|P), P, V) :- dictionnaire(v, nom, V).</p>
<p>Adj(A, R, T, V) :- dictionnaire(A, adj, R, T, V).</p>
<p>&nbsp;</p>
<p>semantic_analyzer :-</p>
<p>&nbsp;&nbsp;&nbsp; read_sentence(P),</p>
<p>&nbsp;&nbsp;&nbsp; phrase_imperative(P, G),</p>
<p>&nbsp;&nbsp;&nbsp; write(G), /.</p>
<p>&nbsp;</p>
<p>phrase_imperative(P, G) :-</p>
<p>&nbsp;&nbsp;&nbsp; Verbe(P, P1, V),</p>
<p>&nbsp;&nbsp;&nbsp; GN(P1, P2, N1, E_GN1, S1),</p>
<p>&nbsp;&nbsp;&nbsp; eq(G1, [V]-obj-&gt;[N1]),</p>
<p>&nbsp;&nbsp;&nbsp; eq(G1, [V]-obj-&gt;E_N_G1),</p>
<p>&nbsp;&nbsp;&nbsp; maximalJoin(G1, E_N_G1, S1, E_GN1, G1_S1,
_),</p>
<p>&nbsp;&nbsp;&nbsp; Prep(P2, P3, s_prep),</p>
<p>&nbsp;&nbsp;&nbsp; GN(P3, (), N2, E_GN2, S2),</p>
<p>&nbsp;&nbsp;&nbsp; eq(G2, [V]-s_prep-&gt;[N2]),</p>
<p>&nbsp;&nbsp;&nbsp; eq(G2, [V]-s_prep-&gt;E_N_G2),</p>
<p>&nbsp;&nbsp;&nbsp; maximalJoin(G2, E_N_G2, S2, E_GN2, G2_S2,
_),</p>
<p>&nbsp;&nbsp;&nbsp; eq(E_V_GS1-obj-&gt;x, G1_S1),</p>
<p>&nbsp;&nbsp;&nbsp; eq(E_V_GS2-s_prep-&gt;y, G2_S2),</p>
<p>&nbsp;&nbsp;&nbsp; maximalJoin(G1_S1, E_V_GS1, G2_S2, E_V_GS2,
G, _).</p>
<p>&nbsp;</p>
<p>GN(P, P1, N, E, G) :-</p>
<p>&nbsp;&nbsp;&nbsp; Art(P, P2, A1),</p>
<p>&nbsp;&nbsp;&nbsp; AdjsSynt(P2, P3, L_Adjs),</p>
<p>&nbsp;&nbsp;&nbsp; Nom(P3, P4, N),</p>
<p>&nbsp;&nbsp;&nbsp; SemAdjs(L_Adjs, N, A1, S, E1),</p>
<p>&nbsp;&nbsp;&nbsp; AdjsSynt(P4, P1, L_Adjs2),</p>
<p>&nbsp;&nbsp;&nbsp; SemAdjs(L_Adjs2, N, A1, S1, E11),</p>
<p>&nbsp;&nbsp;&nbsp; maximalJoin(S, E1, S1, E11, G, E).</p>
<p>&nbsp;</p>
<p>AdjsSynt((A|P), P1, (A|L_Adjs)) :-</p>
<p>&nbsp;&nbsp;&nbsp; dictionnaire(A, adj, _, _, _),</p>
<p>&nbsp;&nbsp;&nbsp; AdjsSynt(P, P1, L_Adjs), /.</p>
<p>AdjsSynt(P, P, ()).</p>
<p>&nbsp;</p>
<p>SemAdjs((A|P), N, A1, S, E_N_S) :-</p>
<p>&nbsp;&nbsp;&nbsp; Adj(A, R1, T1, V1),</p>
<p>&nbsp;&nbsp;&nbsp; eq(G, [N : A1]-R1-&gt;[T1 = V1]),</p>
<p>&nbsp;&nbsp;&nbsp; eq(G, E_N-R1-&gt;x),</p>
<p>&nbsp;&nbsp;&nbsp; SemAdjs2(P, G, E_N, N, A1, S, E_N_S), /.</p>
<p>SemAdjs((), N, A1, G, E) :-</p>
<p>&nbsp;&nbsp;&nbsp; eq(G, [N : A1]),</p>
<p>&nbsp;&nbsp;&nbsp; eq(G, E-rel-&gt;[Universal]), /.</p>
<p>&nbsp;</p>
<p>SemAdjs2((A|P), G, E_N, N, A1, S, E_S) :-</p>
<p>&nbsp;&nbsp;&nbsp; Adj(A, R, T, V),</p>
<p>&nbsp;&nbsp;&nbsp; eq(G1, [N : A1]-R-&gt;[T = V]),</p>
<p>&nbsp;&nbsp;&nbsp; eq(G1, E_N1-R-&gt;x),</p>
<p>&nbsp;&nbsp;&nbsp; maximalJoin(G, E_N, G1, E_N1, G2, E_N2),</p>
<p>&nbsp;&nbsp;&nbsp; SemAdjs2(P, G2, E_N2, N, A1, S, E_S), /.</p>
<p>SemAdjs2((), G, E, _, _, G, E).</p>
<p>&nbsp;</p>
<p><small><font face="Courier New">?- semantic_analyzer.<br>
|:mets la petite pyramide rouge sur le grand cube bleu<br>
[METTRE] -<br>
&nbsp;&nbsp;&nbsp; -obj-&gt;[PYRAMIDE] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-tailleDe-&gt;[TAILLE = petite],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-couleurDe-&gt;[COULEUR = rouge];,<br>
&nbsp;&nbsp;&nbsp; -sur-&gt;[CUBE] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-tailleDe-&gt;[TAILLE = grand],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-couleurDe-&gt;[COULEUR = bleu]<br>
{}<br>
<br>
?-</font></small></p>
<p>&nbsp;</p>
<p><big><big><font face="Garamond"><b>15. <a name=
"metaOperations"></a>Meta-operations</b></font></big></big></p>
<p><font face="Garamond">Figure 7 presents the current
meta-operations of PROLOG+CG : <a href="#cut">cut</a> : "/",
<a href="#free/1">free</a>, <a href="#findall/3">findall</a>,
&nbsp; <a href="#read">read</a> , <a href=
"#readSentence">read_sentence</a>, <a href="#write">write</a>,
<a href="#asserta">asserta, assertz</a>, <a href=
"#retract">retract, suppress</a>, <a href="#termList">term_list</a>
, <a href="#set_list">set_list</a>, and <a href=
"#CreateInstance">createInstance</a> (this operator is introduced
later, in another section). Except createInstance, meta-operations
are similar to the corresponding ones in the other PROLOG versions.
Of course we have extended them to consider CG as another basic
data structure. For instance, the fact to assert may be represented
by a CG (not only a term).</font></p>
<p align="center"><img src="EnvPrimHierMeta.png" alt=
"EnvPrimHierMeta.png (14377 octets)"></p>
<p align="center"><strong>Figure 7 :</strong> Meta-Goals of
PROLOG+CG</p>
<p><a name="cut"></a><font face="Garamond"><b>Operator Cut/0&nbsp;
: "/"</b></font></p>
<p><font face="Garamond">To control the resolution process and to
get a more efficient search engine, PROLOG+CG, like the most Prolog
versions, provides the cut operator (represented often by "/"). The
cut operator "/" is considered as a term with a special identifier
("/") and no arguments. It can be used as a goal in the tail of an
inference rule.</font></p>
<p><font face="Garamond"><em><strong>Example</strong></em>
:</font></p>
<p><font size="2" face="Courier New">OurMember(e, (e | _)) :-
/.</font></p>
<p><font size="2" face="Courier New">OurMember(e, (_ | x)) :-
OurMember(e, x), /.</font></p>
<p>&nbsp;</p>
<p><font size="2" face="Courier New">?- OurMember(x, (1, 3, 5,
7)).</font></p>
<p><font size="2" face="Courier New">{x = 1}</font></p>
<p><font size="2" face="Courier New">?-</font></p>
<p><a name="free/1"></a><strong><font face="Garamond">Operator
free/1 :</font></strong><font face=
"Courier New"><small>free(Variable)</small> <em>; check if the
variable is free</em></font></p>
<p><font face="Garamond"><em><strong>Example</strong></em>
:</font></p>
<p><font size="2" face="Courier New">?- free(x).</font></p>
<p><font size="2" face="Courier New">{}</font></p>
<p><font size="2" face="Courier New">?- eq(x, 45),
free(x).</font></p>
<p><font size="2" face="Courier New">no</font></p>
<p>&nbsp;</p>
<p><a name="findall/3"></a><font face="Garamond"><strong>Operator
findall/3 :</strong></font><font face=
"Courier New"><small>findall(Variable, Goal, List)</small> <em>;
return in List all the values of Variable that result from all the
possible resolution of Goal</em></font></p>
<p><font face="Garamond"><em><strong>Example</strong></em>
:</font></p>
<blockquote>
<p><small><font face="Courier New">donnee(4, jjj).<br>
donnee(5, hhh).<br>
donnee(6, kkkk).<br>
<br>
data(10, kkk).<br>
data(20, ddd).<br>
data(30, ffff).<br>
data(40, rrrr).<br>
<br>
datum(x) :-<br>
&nbsp;&nbsp;&nbsp; donnee(x, _).<br>
datum(x) :-<br>
&nbsp;&nbsp;&nbsp; data(x, _).<br>
<br>
ex(m) :-&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp; findall(a, datum(a), L),<br>
&nbsp;&nbsp;&nbsp; moyenne(L, m), /.<br>
<br>
moyenne(L, m) :-<br>
&nbsp;&nbsp;&nbsp; length(L, n),<br>
&nbsp;&nbsp;&nbsp; somme(L, 0, s),<br>
&nbsp;&nbsp;&nbsp; val(m, div(s, n)), /.<br>
<br>
somme((x|L), s1, s2) :-<br>
&nbsp;&nbsp;&nbsp; val(s3, add(x, s1)),<br>
&nbsp;&nbsp;&nbsp; somme(L, s3, s2), /.<br>
&nbsp;&nbsp;&nbsp; somme((), s, s).</font></small></p>
<p>&nbsp;</p>
<p><small><font face="Courier New">?-ex(m).<br>
<br>
{m = 16.428571428571427}<br>
<br>
?-</font></small></p>
<p>&nbsp;</p>
</blockquote>
<p><font face="Garamond"><b>Operator</b></font><a name=
"read"></a><font face="Garamond"><b>read&nbsp; :</b></font>
<font size="2" face="Courier New">read(Free_Variable)</font></p>
<p><font face="Garamond">The argument of "read" should be a free
variable at the moment of its execution. When a read operation is
executed, the system will prompt the user with the symbol "|:" and
the user should give his data which could take several lines (a
simple data like a number, a boolean, an identifier, a string or a
composed data like a term, a list or a CG) and it should terminate
with a point ".". Once his data is edited, the user should press on
the key "Enter".</font></p>
<p><strong><font face="Garamond">Example :</font></strong></p>
<p><font size="2" face="Courier New">?- read(x).</font></p>
<p><font size="2" face="Courier New">|: papa(Ahmed,</font></p>
<p><font size="2" face="Courier New">Goerge).</font></p>
<p><font size="2" face="Courier New">{x = papa(Ahmed,
Goerge)}</font></p>
<p><font size="2" face="Courier New">?-</font></p>
<p>&nbsp;</p>
<p><a name="readSentence"></a><strong><font face=
"Garamond">Operator read_sentence :</font></strong>
<small><font face=
"Courier New">read_sentence(Free_Variable)</font></small></p>
<p>read_sentence reads a sentence (i.e. a sequence of characters)
and returns the list of "words" that composes it.</p>
<p><strong>Example :</strong></p>
<p><small><font face="Courier New">?-
read_sentence(p).</font></small></p>
<p><font size="2" face="Courier New">|: this is a simple sentence,
with a comma inside.</font></p>
<p><font size="2" face="Courier New">{p = ("this", "is", "a",
"simple", "sentence", ",", "with", "a", "comma", "inside",
".")}</font></p>
<p>&nbsp;</p>
<p><a name="readSentence"></a><strong><font face=
"Garamond">Operator read_sentence :</font></strong>
<small><font face="Courier New">read_sentence(Sentence,
Free_Variable)</font></small></p>
<p>read_sentence returns in its second argument the list of words
that compose its first argument (which is a String).</p>
<p><strong>Example :</strong></p>
<p><font face="Courier New"><small>?-
read_sentence("</small></font><font size="2" face=
"Courier New">this is another sentence</font><font face=
"Courier New"><small>", L).</small></font></p>
<p><font size="2" face="Courier New">{L = ("this", "is", "another",
"sentence")}</font></p>
<p>&nbsp;</p>
<p><font face="Garamond"><b>Operator</b></font> <a name=
"write"></a><font face="Garamond"><b>write &nbsp; :</b></font>
<font size="2" face="Courier New">write(Data)</font></p>
<p><font face="Garamond">The argument of write is any PROLOG+CG
data.</font></p>
<p>&nbsp;</p>
<p><b><font face="Garamond">Operators</font></b> <a name=
"asserta"></a><font face="Garamond"><b>asserta and assertz&nbsp;
:</b></font> <font size="2" face="Courier New">asserta(Goal,
List_Of_Goals)</font></p>
<p><font face="Garamond">Asserta/assertz adds to the current
program a new rule at the top of the packet (if it exists) while
assertz adds the rule at the bottom of the packet. The first
argument of asserta (and assertz) represents the head of the new
rule while the second argument represents the tail expressed as a
list. Of course, when the new rule is a fact, the list is
empty.</font></p>
<p>&nbsp;</p>
<p><b><font face="Garamond">Operators</font></b> <a name=
"retract"></a><font face="Garamond"><b>retract/suppress&nbsp;
:</b></font> <font size="2" face="Courier New">retract(Goal) &amp;
suppress(TermId, NbreArg)</font></p>
<p><font face="Garamond">Retract eliminates from the current
program any rule with a head that can be unified with its
argument.</font></p>
<p><font face="Garamond">Suppress eliminates a whole packet of
rules. The two arguments of suppress (an identifier and an integer)
enables the identification of the packet.</font></p>
<p>&nbsp;</p>
<p><b><font face="Garamond">Operator</font></b> <a name=
"termList"></a><font face="Garamond"><b>term_list&nbsp;
:</b></font> <font size="2" face="Courier New">term_list(Term,
List)</font></p>
<p><font face="Garamond">term_list transforms a term to a list and
vice versa.</font></p>
<p><strong><font face="Garamond">Example :</font></strong></p>
<p><font size="2" face="Courier New">?- eq(x, papa), term_list(t,
(x, Ahmed, y)).</font></p>
<p><font size="2" face="Courier New">{x = papa, t = papa(Ahmed, y),
y = FREE}</font></p>
<p>&nbsp;</p>
<p><font face="Garamond">Now, suppose that we have a program that
contains this packet :</font></p>
<p><font size="2" face="Courier New">papa(Ahmed,
Soumia).</font></p>
<p><font size="2" face="Courier New">papa(Sahir,
Fatine).</font></p>
<p><font size="2" face="Courier New">papa(Ahmed,
Khalid).</font></p>
<p>&nbsp;</p>
<p><font face="Garamond">We ask again the previous question but in
addition, we want to execute the new composed term t :</font></p>
<p><font size="2" face="Courier New">?- eq(x, papa), term_list(t,
(x, Ahmed, y)), t.</font></p>
<p><font size="2" face="Courier New">{x = papa, t = papa(Ahmed,
Soumia), y = Soumia}</font></p>
<p><font size="2" face="Courier New">{x = papa, t = papa(Ahmed,
Khalid), y = Khalid}</font></p>
<p>&nbsp;</p>
<p><a name="set_list"></a><b><font face=
"Garamond">Operator</font></b> <a name="termList"></a><font face=
"Garamond"><b>set_list&nbsp; :</b></font> <font size="2" face=
"Courier New">set_list(Set, List)</font></p>
<p><font face="Garamond">set_list transforms a set to a list and
vice versa.</font></p>
<p><strong><font face="Garamond">Example :</font></strong></p>
<p><font size="2" face="Courier New">?- set_list(s, (Karim, Ahmed,
Hicham)).</font></p>
<p><font size="2" face="Courier New">{s = {Karim, Ahmed,
Hicham}}</font></p>
<p>&nbsp;</p>
<p><font size="2" face="Courier New">?- set_list({Karim, Ahmed,
Hicham}, L).</font></p>
<p><font size="2" face="Courier New">{L = (Karim, Ahmed,
Hicham)}</font></p>
<p>&nbsp;</p>
<p><strong><font face="Garamond"><big><big>16. </big></big><a name=
"visualDebug"></a><big><big>The visual debugger of
PROLOG+CG</big></big></font></strong></p>
<p><font face="Garamond">PROLOG+CG provides a powerfull debugger
that visualizes the inference/resolution process as a
construction/deconstruction (due to a backtrack) of the inference
tree. Figure 7 gives a snapshot that shows the debugger in action.
The figure shows also an auxiliary window : "a variable inspection
window". This type of window is introduced next.</font></p>
<p align="center"><img src="Debug.png" alt=
"Debug.png (10788 octets)"></p>
<p align="center"><font face="Garamond"><strong>Figure 7 : The
visual Debugger of PROLOG+CG</strong></font></p>
<p align="left"><font face="Garamond">To debug (or trace, follow)
the resolution/satisfaction of a request (we assume that the
program has been compiled), choose from the menu the option
"Build/Debug" and then activate the interpreter as usual. The debug
window appears. The current goal is the selected node in the visual
tree. Next, you must guide the debugger. Three main actions are
provided for that (they are represented by the three icons in the
toolBar of the debug window)&nbsp; :</font></p>
<ul>
<li>
<p align="left" style="vertical-align: middle"><font face=
"Garamond"><strong>"Inside"</strong> &nbsp; iconified by&nbsp;
<img src="InStepBt.png" alt="InStepBt.png (1200 octets)"> : "Inside
the current step" means debug the current goal. If the fact is a
fact, a message will annonce it, otherwise the debugger will expand
the visual tree and the new current goal is the first "child" of
the list. If the current goal can't be resolved and the resolution
process backtracks, the debugger will backtrack also to the
previous node.</font></p>
</li>
<li>
<p align="left"><font face="Garamond"><strong>"Skip"</strong>
iconified by <img src="SkipStepBt.png" alt=
"SkipStepBt.png (1189 octets)"> : "Skip" means not debug the
current goal. Again, if the current goal can't be resolved and the
resolution process backtracks, the debugger will backtrack also to
the previous node.</font></p>
</li>
<li>
<p align="left"><font face="Garamond"><strong>"Stop"</strong>
iconified by <img src="StopStepBt.png" alt=
"StopStepBt.png (1235 octets)"> : Stop the debugger; the resolution
process will continue without his compagnon !</font></p>
</li>
</ul>
<p align="left"><font face="Garamond"><em><strong>Visualization of
backtracking :</strong></em> the normal resolution process expands
the inference tree; the debugger will expand also the visual tree.
A backtrack step done by the resolution process involves
contraction and backward move in the visual tree. Also, once the
resolution process finds one solution and writes it in the console
panel, it will continue (by default) to search for other solutions
and the user can continue to use the debugger to follow
it.</font></p>
<p align="left">&nbsp;</p>
<p align="left"><strong><big><font face="Garamond">Goal/Variable
inspection facility</font></big></strong></p>
<p align="left"><font face="Garamond">While debugging, it is very
usefull to inspect the instanciation form of a goal and/or the
value of a specific variable (if the user wants to do so). The
visual debugger of PROLOG+CG allows the two :</font></p>
<ul>
<li>
<p align="left"><font face="Garamond"><em><strong>inspect the
instanciated form of a node :</strong></em> click on the node
(left-right, or right-left) to get the instanciated view of the
node. The content of the node is changed. You can click again to
come-back to the previous content of the node. So a sequence of
alternative left/right clicks will switch the content of the node
from the generic view to the instanciated one. You can also
double-click to get the instanciated view in an auxiliary
window.</font></p>
</li>
<li>
<p align="left"><font face="Garamond"><strong><em>inspect a
specific variable :</em></strong> select, from the main menu, the
option "Build/Inspect variable", specifies in the text field the
identifier of the variable (like "a/1" , without the double quotes)
and press on "OK". An auxiliary window will then appear with the
value of the variable. An example of such an auxiliary window is
given in Figure 7.</font></p>
</li>
</ul>
<p align="left">&nbsp;</p>
<p><font face="Garamond"><strong><big><big>17.</big></big> <a name=
"ExpertMode"></a><big><big>The Expert System
Mode</big></big></strong></font></p>
<p><font face="Garamond">One of the main achievment of PROLOG
was/is its use in the development of expert system (ES) shells.
Most often, developers used PROLOG to implement an ES shell, on top
of it. In PROLOG+CG, the kernel of an ES shell is integrated
directly in the interpreter. Thus, a simple check-item, as
explained below, will switch the system from the default resolution
process to the "ES shell resolution process".</font></p>
<p><font face="Garamond">When the default resolution process (the
usual interpreter of most PROLOG versions) attempts to resolve a
goal that is not a primitive goal, neither a defined goal (no rule
can be found so that its head unifies with the goal), it will
conclude that the goal can't be resolved and it will backtrack.
However, the kernel of an ES shell will proceed otherwise : it will
not conclude that the goal can't be resolved, it will ask the user
about the truth of the goal ("is the current goal true or false ? :
yes/no"). The process will conclude depending on the answer of the
user and the user answer will be added to the database, in order to
be considered later (and not to ask again and again the same
question).</font></p>
<p><font face="Garamond">Actually, PROLOG+CG provides only this
aspect of the ES shell. Other aspects, like the explication of the
resolution process behavior (why/how) and forward chaining will be
integrated in the next version of PROLOG+CG.</font></p>
<p><font face="Garamond">To activate the "expert system mode" of
PROLOG+CG, choose from the main menu the action "Build/expert
system mode". The following examples illustrate this PROLOG+CG
feature.</font></p>
<p>&nbsp;</p>
<p><strong><font face="Garamond">Example 1 : Propositional
ES</font></strong></p>
<p><font face="Garamond">This example illustrates the possibility
to define a <big><em>propositional ES</em></big> using PROLOG+CG. A
propositional ES is an ES where any proposition is represented by a
non-analyzable string. This later is considered as a symbole
(likewise in propositional logic, we use symbols like p, q, r .. to
represent propositions).</font></p>
<p><small><font face="Courier New">"animal is carnivore" :- "animal
eats meat".<br>
"animal is carnivore" :-<br>
&nbsp;&nbsp;&nbsp; "animal has pointed teeth",<br>
&nbsp;&nbsp;&nbsp; "animal has claws",<br>
&nbsp;&nbsp;&nbsp; "animal has forward eyes".<br>
<br>
"animal is penguin" :-<br>
&nbsp;&nbsp;&nbsp; "animal is bird",<br>
&nbsp;&nbsp;&nbsp; "animal swims",<br>
&nbsp;&nbsp;&nbsp; "animal is black and white".<br>
<br>
"animal is ungulate" :- "animal is mammal", "animal has hoofs".<br>
"animal is ungulate" :- "animal is mammal", "animal chews cud".<br>
<br>
"animal is mammal" :- "animal has hair".<br>
<br>
"animal is ostrich" :- "animal is bird", "animal has long neck",
"animal has long legs", "animal is black and white".<br>
<br>
"animal is zebra" :- "animal is ungulate",&nbsp; "animal has black
stripes".<br>
<br>
"animal is tiger" :-<br>
&nbsp;&nbsp;&nbsp; "animal is mammal",<br>
&nbsp;&nbsp;&nbsp; "animal is carnivore",<br>
&nbsp;&nbsp;&nbsp; "animal has twany color",<br>
&nbsp;&nbsp;&nbsp; "animal has black stripes".<br>
<br>
"animal is cheetah" :-<br>
&nbsp;&nbsp;&nbsp; "animal is mammal",<br>
&nbsp;&nbsp;&nbsp; "animal is carnivore",<br>
&nbsp;&nbsp;&nbsp; "animal has twany color",<br>
&nbsp;&nbsp;&nbsp; "animal has dark spots".<br>
<br>
"animal is giraffe" :-<br>
&nbsp;&nbsp;&nbsp; "animal is ungulate",<br>
&nbsp;&nbsp;&nbsp; "animal has long neck",<br>
&nbsp;&nbsp;&nbsp; "animal has long legs",<br>
&nbsp;&nbsp;&nbsp; "animal has dark spots".<br>
<br>
"animal is bird" :- "animal has feathers".<br>
"animal is bird" :- "animal flies", "animal lays
eggs".<br></font></small></p>
<p><font face="Garamond">To swith on the "expert system mode", the
user has to choose from the main menu the option "Build/Expert
System Mode". Then, compile the program. Here is a part of an
interaction with the system.</font></p>
<p><small><font face="Courier New">?- "animal is tiger".<br>
==&gt; Is it true that : "animal has hair" ? tape y (for yes) or n
(for no) : y<br>
==&gt; Is it true that : "animal eats meat" ? tape y (for yes) or n
(for no) : y<br>
==&gt; Is it true that : "animal has twany color" ? tape y (for
yes) or n (for no) : y<br>
==&gt; Is it true that : "animal has black stripes" ? tape y (for
yes) or n (for no) : y<br>
{}<br>
==&gt; Is it true that : "animal has pointed teeth" ? tape y (for
yes) or n (for no) : n<br>
<br>
?-</font></small></p>
<p><font face="Garamond">After this interaction, PROLOG+CG added to
the program the following facts :</font></p>
<p><font face="Courier New"><small>"animal has twany color".<br>
"animal has black stripes".<br>
"animal eats meat".<br>
"animal has hair".<br>
"animal has pointed teeth" :- fail.</small></font></p>
<p><font face="Garamond">Note how the "no" answer is interpreted :
assertion of a new rule with the proposition as the head and the
primitive goal "fail" as a tail. The <strong>fail</strong> goal is
no-satisfied by definition.</font></p>
<p><font face="Garamond">The reformulation of this ES using
predicates/terms instead of non-analyzable String, is left as an
exercice.</font></p>
<p>&nbsp;</p>
<p><strong><font face="Garamond">Example 2 : An ES that uses
CG</font></strong></p>
<p>To illustrate the use of CG in the formulation of ES, we will
reformulate the same ES with the of CG only.</p>
<p><small><font face="Courier New">Universal &gt; Object, Animal,
Person, Action, State, Attribute.<br>
Object &gt; Hair, Meat, Teeth, Claw, Eye.<br>
Animal &gt; Mammal, Carnivore, Cheetah.<br>
Person &gt; Man.<br>
Action &gt; Eat.<br>
State &gt; Belong.<br>
Attribute &gt; Color, Component, Twany, Dark, Pointed, Forward.<br>
<br>
Man = Robert.<br>
Animal = Yala.<br>
<br>
[Animal : x]-is-&gt;[Cheetah] :-<br>
&nbsp;&nbsp;&nbsp; [Animal : x]-is-&gt;[Mammal],<br>
&nbsp;&nbsp;&nbsp; [Animal : x]-is-&gt;[Carnivore],<br>
&nbsp;&nbsp;&nbsp; [Animal :
x]-colorOf-&gt;[Color]-attr-&gt;[Twany],<br>
&nbsp;&nbsp;&nbsp; [Animal :
x]-partOf-&gt;[Component]-attr-&gt;[Dark].<br>
<br>
[Animal : x]-is-&gt;[Mammal] :-<br>
&nbsp;&nbsp;&nbsp; [Animal : x]-poss-&gt;[Hair].<br>
<br>
<br>
[Animal : x]-is-&gt;[Carnivore] :-<br>
&nbsp;&nbsp;&nbsp; [Animal : x]&lt;-agnt-[Eat]-obj-&gt;[Meat].<br>
<br>
[Animal : x]-is-&gt;[Carnivore] :-<br>
&nbsp;&nbsp;&nbsp; [Animal :
x]-poss-&gt;[Teeth]-attr-&gt;[Pointed],<br>
&nbsp;&nbsp;&nbsp; [Animal : x]-poss-&gt;[Claw],<br>
&nbsp;&nbsp;&nbsp; [Animal :
x]-has-&gt;[Eye]-attr-&gt;[Forward].<br>
<br></font></small><font face="Garamond">Unlike the first
formulation of the ES, we add to the CG formulation the following
fact, to give a "punch" to our example !</font></p>
<p><small><font face="Courier New">[Animal : Yala]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;-pat-[Belong]-bnfcre-&gt;[Man : Robert],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-colorOf-&gt;[Color]-attr-&gt;[Twany],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-poss-&gt;[Teeth]-attr-&gt;[Pointed],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-has-&gt;[Eye]-attr-&gt;[Forward].</font></small></p>
<p><font face="Garamond">Now, we can ask the following question
:</font></p>
<p><font face="Courier New"><small>?- [Animal :
Yala]-is-&gt;[Cheetah].<br>
==&gt; The goal : [Animal : Yala]-poss-&gt;[Hair] cannot be infered
from what is known, so<br>
==&gt; Is it true that : [Animal : Yala]-poss-&gt;[Hair] ? tape y
(for yes) or n (for no) : y<br>
==&gt; The goal : [Eat] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Meat],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Animal : Yala] cannot be infered from what is known,
so<br>
==&gt; Is it true that : [Eat] -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-obj-&gt;[Meat],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-agnt-&gt;[Animal : Yala] ? tape y (for yes) or n (for no) : y<br>
==&gt; The goal : [Animal :
Yala]-partOf-&gt;[Component]-attr-&gt;[Dark] cannot be infered from
what is known, so<br>
==&gt; Is it true that : [Animal :
Yala]-partOf-&gt;[Component]-attr-&gt;[Dark] ? tape y (for yes) or
n (for no) : y<br>
{}<br>
==&gt; The goal : [Animal : Yala]-poss-&gt;[Claw] cannot be infered
from what is known, so<br>
==&gt; Is it true that : [Animal : Yala]-poss-&gt;[Claw] ? tape y
(for yes) or n (for no) : n<br>
<br>
?-</small></font></p>
<p><font face="Garamond">After this interaction, PROLOG+CG added to
the program the following facts :</font></p>
<p><font face="Courier New"><small>[Animal :
Yala]-poss-&gt;[Hair].<br>
[Eat] -<br>
&nbsp;&nbsp;&nbsp; -obj-&gt;[Meat],<br>
&nbsp;&nbsp;&nbsp; -agnt-&gt;[Animal : Yala].<br>
[Animal : Yala]-partOf-&gt;[Component]-attr-&gt;[Dark].<br>
[Animal : Yala]-poss-&gt;[Claw] :- fail.</small></font></p>
<p>&nbsp;</p>
<p><font face="Garamond"><big><strong>Remarks
:</strong></big></font></p>
<ol>
<li><font face="Garamond">There is an important difference between
the treatment of "propositional"/"predicate" ES and "CG" ES. For a
predicate ES, if the current goal/proposition to satisfy has the
same signature (the predicate identifier with the number of
arguments) as the head of a rule in the ES then we will not ask the
user for the truth of the goal/proposition, even if the goal is not
satisfied. The reason is that we have at least a rule that is able
to compute the truth of the goal/proposition. Concerning CG ES, we
have not the equivalent of a predicate signature : To satisfy a
goal/proposition, we have to consider all the rules with CG as
head, if no one can be unified with the goal, then we conclude that
no existant rule can infer the truth of the goal and so we ask the
user for. Of course, if the head can be unified, then we will not
ask the reader, even if the tail of the rule cannot be
satisfied.</font></li>
<li><font face="Garamond">To return to the default mode of
PROLOG+CG, don't forget to switch off the "Expert System Mode" from
the main menu and from "Build".</font></li>
</ol>
<p>&nbsp;</p>
<p><font face="Garamond" size="5"><strong>18.</strong></font>
<big><big><a name="Objects"></a><font face="Garamond"><b>Objects,
messages and object-based programming</b></font></big></big></p>
<p><font face="Garamond">Sometime and especially for a big
knowledge-base system (written in Prolog), it is useful to
partition the base in several partitions, contexts or objects, each
one includes a set of packets. Of course, such a partition will be
really useful only if the inference engine (i.e., the resolution
process) is adapted accordingly; resolution of a goal will be
restricted to the object where it is defined.</font></p>
<p><font face="Garamond">The definition of objects and the
contextual resolution of goals form the basis for logic
object-based programming.</font></p>
<p><font face="Garamond"><b>Object in PROLOG+CG.</b> <i>An
object</i> is a set of rules prefixed by terms with an identical
signature. An object has the following form :</font></p>
<p><font size="2" face="Courier New">T1::R1</font></p>
<p><font size="2" face="Courier New">T2::R2</font></p>
<p><font size="2" face="Courier New">&hellip;</font></p>
<p><font size="2" face="Courier New">Tn::Rn</font></p>
<p><font face="Garamond">Where T1, T2, &hellip;, Tn represent terms
with the same signature and R1, R2, &hellip;, Rn stand for
PROLOG+CG inference rules. The common signature to the T1, T2,
&hellip;, Tn constitutes the <i>descriptor of the
object</i>.</font></p>
<p><font face="Garamond">Sending a message to an object will
correspond to a contextual resolution of a goal.</font></p>
<p><font face="Garamond"><b>Sending a message.</b> <i>Sending a
message</i> to an object is expressed as a <i>composed goal</i> :
T::G, where T represents a term and G a goal (i.e., which could be
a term, a CG or a variable). T::G can be read : "send a message to
the object O<sub>T</sub> to execute (satisfy) the goal G".
O<sub>T</sub> is the object which its descriptor is the same as the
signature of T.</font></p>
<p><font face="Garamond">To satisfy a composed goal T::G, the
interpreter locates first an object with a descriptor that
corresponds to the signature of the term T. Then it searches
<b><i>inside</i></b> the object for a prefixed rule Ti::Ri such
that T::G can be unified with Ti::HeadOf(Ri) : the interpreter
tries to unify T with Ti and the goal G with the head of the rule
Ri.</font></p>
<p><font face="Garamond"><b>Remark.</b> A rule can be prefixed also
by a CG :</font> <font size="2" face=
"Courier New">CG::R</font><font face="Garamond">. In this case, all
the rules of the program that are prefixed by CG constitute one
object. Also, a composed goal can have the form :</font>
<font size="2" face="Courier New">CG::Goal.</font></p>
<p>&nbsp;</p>
<p><strong><font face="Garamond" size="5">19.</font>
<big><big><big><a name="Sample3"></a></big></big><font face=
"Garamond"><b>Samples IV</b></font></big></strong></p>
<p><font face="Garamond">This section presents two programs that
illustrate the object-based level of PROLOG+CG.</font></p>
<p><font face="Garamond"><strong>Example 1 (can be found in
Samples/Hamza.prlg) :</strong></font></p>
<p><font size="2" face=
"Courier New">hamza::[PERSON]-DateOfBirth-&gt;[BIRTH]-ptime-&gt;[DATE=(5,04,1995)].</font></p>
<p><font size="2" face="Courier New">hamza::Age(A) :-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="7%"></td>
<td valign="top" width="93%"><font size="2" face=
"Courier New">currentDate(D1),</font>
<p><font size="2" face=
"Courier New">hamza::[PERSON]-DateOfBirth-&gt;[BIRTH]-ptime-&gt;[DATE
= D2],</font></p>
<p><font size="2" face="Courier New">diffDate(D1, D2,
A).</font></p>
</td>
</tr>
</table>
<p><font size="2" face="Courier New">currentDate((14, 12,
1999)).</font></p>
<p><font size="2" face="Courier New">diffDate((x_Day2, y_month2,
z_year2), (x_Day1, y_month1, z_year1),</font> <font size="2" face=
"Courier New">(x_Day, y_month, z_year)) :-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="6%"></td>
<td valign="top" width="58%"><font size="2" face=
"Courier New">val(x_Day, sub(x_Day2, x_Day1)),</font>
<p><font size="2" face="Courier New">val(y_month, sub(y_month2,
y_month1)),</font></p>
<p><font size="2" face="Courier New">val(z_year, sub(z_year2,
z_year1)), /.</font></p>
</td>
<td valign="top" width="36%"></td>
</tr>
</table>
<p><font face="Garamond">Lest us ask some questions :</font></p>
<p><font size="2" face="Courier New">?-
hamza::[BIRTH]-ptime-&gt;[DATE = d].</font></p>
<p><font size="2" face="Courier New">{d = (5, 04, 1995)}</font></p>
<p><font size="2" face="Courier New">?- hamza::Age(x).</font></p>
<p><font size="2" face="Courier New">{x = (9, 8, 4)}</font></p>
<p>&nbsp;</p>
<p><font face="Garamond"><strong>Example 2 (it can be found in
Samples/ConcStrs.prlg) :</strong></font></p>
<p><font size="2" face="Courier New">Universal &gt; Animate,
Inanimate, Action.</font></p>
<p><font size="2" face="Courier New">Action &gt;
Extract.</font></p>
<p><font size="2" face="Courier New">Animate &gt;
Person.</font></p>
<p><font size="2" face="Courier New">Person &gt; Student,
Employee.</font></p>
<p><font size="2" face="Courier New">Student &gt;
ResearchAssistant.</font></p>
<p><font size="2" face="Courier New">Employee &gt;
ResearchAssistant.</font></p>
<p><font size="2" face="Courier New">Inanimate &gt;
Text.</font></p>
<p><font size="2" face="Courier New">Text &gt; Book.</font></p>
<p><font size="2" face="Courier New"><i>// Conceptual structures
for the type Extract constitutes an object</i></font></p>
<p><font size="2" face=
"Courier New">Extract(canon)::[Extract]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="27%"></td>
<td valign="top" width="73%"><font size="2" face=
"Courier New">-agnt-&gt;[Person],</font>
<p><font size="2" face=
"Courier New">-obj-&gt;[Inanimate].</font></p>
</td>
</tr>
</table>
<p><font size="2" face=
"Courier New">Extract(schema)::[Extract]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="27%"></td>
<td valign="top" width="73%"><font size="2" face=
"Courier New">-agnt-&gt;[Person],</font>
<p><font size="2" face="Courier New">-obj-&gt;[Text],</font></p>
<p><font size="2" face="Courier New">-target-&gt;[Book].</font></p>
</td>
</tr>
</table>
<p><font size="2" face=
"Courier New">Extract(schema)::[Extract]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="27%"></td>
<td valign="top" width="73%"><font size="2" face=
"Courier New">-agnt-&gt;[Person],</font>
<p><font size="2" face="Courier New">-obj-&gt;[Inanimate :
*1],</font></p>
<p><font size="2" face="Courier New">-manr-&gt;[Strong],</font></p>
<p><font size="2" face=
"Courier New">-target-&gt;[Inanimate]-on-&gt;[Inanimate :
*1].</font></p>
</td>
</tr>
</table>
<p><font face="Garamond">The next goal definition involves some
comments ;</font> <font face=
"Courier New"><strong>checkSchemas(v_type)::G</strong></font>
<font face="Garamond">:</font></p>
<p><font face="Garamond">check if the given information in G can be
unified with a schema for the type v_type. First, create a term
v_term from the list (v_type, schema), i.e. v_type (schema), v_type
will be replaced by its value. Second, search a schema v_schema for
the type v_type : v_term::v_schema. Third, check that G can be
unified with v_schema.</font></p>
<p><font size="2" face="Courier New">checkSchemas(v_type)::G
:-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="6%"></td>
<td valign="top" width="94%"><font size="2" face=
"Courier New">term_list(v_term, (v_type, schema)),</font>
<p><font size="2" face="Courier New">v_term::v_schema,</font></p>
<p><font size="2" face="Courier New">eq(v_schema, G).</font></p>
</td>
</tr>
</table>
<p><font face="Garamond">Please note how the expressive power of
PROLOG+CG allows for a very abstract but "effective" formulation;
search all the schema of a type T so that they verify an
information G. Note also how the message (</font><font size="2"
face="Courier New">v_term::v_schema</font><font face="Garamond">)
is dynamically constructed; constructed from two variables : the
object descriptor is a variable (</font><font size="2" face=
"Courier New">v_term</font><font face="Garamond">) and the content
of the message is a variable (</font><font size="2" face=
"Courier New">v_schema</font><font face="Garamond">).</font></p>
<p><font face="Garamond">Let us ask some questions :</font></p>
<p><font face="Garamond"><i>Get all the schemas of the type Extract
:</i></font></p>
<p><font size="2" face="Courier New">?-
Extract(schema)::G.</font></p>
<p><font size="2" face="Courier New">{G = [Extract]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="12%"></td>
<td valign="top" width="88%"><font size="2" face=
"Courier New">-agnt-&gt;[Person],</font>
<p><font size="2" face="Courier New">-obj-&gt;[Text],</font></p>
<p><font size="2" face="Courier New">-target-&gt;[Book]}</font></p>
</td>
</tr>
</table>
<p><font size="2" face="Courier New">{G = [Extract]-</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="12%"></td>
<td valign="top" width="88%"><font size="2" face=
"Courier New">-agnt-&gt;[Person],</font>
<p><font size="2" face=
"Courier New">-obj-&gt;[Inanimate]&lt;-on-[Inanimate :
*1],</font></p>
<p><font size="2" face="Courier New">-manr-&gt;[Strong],</font></p>
<p><font size="2" face="Courier New">-target-&gt;[Inanimate :
*1]}</font></p>
</td>
</tr>
</table>
<p><font face="Garamond"><i>Check if the given information
([Extract]-target-&gt;[Inanimate]) can be unified with one of the
Extract schemas :</i></font></p>
<p><font size="2" face="Courier New">?-
checkSchemas(Extract)::[Extract]-target-&gt;[Inanimate].</font></p>
<p><font size="2" face="Courier New">{}</font></p>
<p><font size="2" face="Courier New">{}</font></p>
<p><font face="Garamond"><i>And check for another information
:</i></font></p>
<p><font size="2" face=
"Courier New">?-checkSchemas(Extract)::[Inanimate]&lt;-from-[Extract]-obj-&gt;[Person].</font></p>
<p><font size="2" face="Courier New">no.</font></p>
<p>&nbsp;</p>
<p><big><big><strong>20. <a name=
"Inheritance"></a></strong><font face="Garamond"><b>Inheritance
rules and Object-oriented programming</b></font></big></big></p>
<p><font face="Garamond">The object-oriented level of PROLOG+CG is
based on the approach proposed by McCabe [15]. Inheritance between
objects is defined by <i>inheritance rules</i>.</font></p>
<p><font face="Garamond"><b>Inheritance rule.</b> It has the
following form :</font></p>
<p><font size="2" face="Courier New">Term1 &lt;-
Term2</font><font face="Garamond"><i>.</i></font></p>
<p><font face="Garamond">where Term1 and Term2 are two terms that
represent two objects. The rule means : the object identified by
Term1 is a specialization of the object identified by Term2. If a
message that is send to an object can not be satisfied, the
interpreter will search an inheritance rule for that object (if it
has) in order to delegate the message to its
super-object.</font></p>
<p><font face="Garamond">The next section gives an example that
illustrates object-oriented programming in PROLOG+CG.</font></p>
<p>&nbsp;</p>
<p><big><big><strong>21.</strong> <a name="sample4"></a><font face=
"Garamond"><b>Samples V</b></font></big></big></p>
<p><font face="Garamond">The following example can be found in
<strong>Samples/OORectSqre.prlg</strong>. It illustrates how a
class (as a set of attributes and a set of methods) can be defined
in PROLOG+CG. Let us consider for instance the definition of the
class Rectangle. Rectangle is defined as an object (in the sense of
PROLOG+CG; an object in this language can represent a class like
Rectangle and/or a specific object like Hamza) identified by the
term</font> <font size="2" face="Courier New">Rectangle(H,
W).</font><font face="Garamond">Its static part (set of attributes)
is described by the first rule, represented by a CG. Notes that the
definition can have some semantic constraints, like the one
expressed in this example : the width should not be inferior to the
height of the rectangle. The constraints are formulated in the tail
of the rule in order to be evaluated when needed.</font></p>
<p><font face="Garamond">The two methods of Rectangle (Perimeter
and Surface) are defined as goals inside the object Rectangle(H,
W).</font></p>
<p><font face="Garamond">Then, another class is defined : Square.
This class is defined as a subclass of the class Rectangle. Notes
the use of terms arguments to precise the modality of such a
relation between the two classes.</font></p>
<p><font size="2" face="Courier New">Universal &gt; Form,
Attribute.</font></p>
<p><font size="2" face="Courier New">Form &gt;
Rectangle.</font></p>
<p><font size="2" face="Courier New">Rectangle &gt;
Square.</font></p>
<p><font size="2" face="Courier New">Attribute &gt; Perimeter,
Surface, Width, Heigth, Beautiful.</font></p>
<p><small><font face="Courier New">Rectangle(H,
W)::[Rectangle]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-permOf-&gt;[Perimeter],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-surfOf-&gt;[Surface],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-widthOf-&gt;[Width = W],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-heigthOf-&gt;[Heigth = H] :-</font></small> <font size="2" face=
"Courier New">not(inf(W, H)).</font></p>
<p><font size="2" face="Courier New">Rectangle(H, W)::Perimeter(P)
:- val(P, mul(2, add(H, W))).</font></p>
<p><font size="2" face="Courier New">Rectangle(H, W)::Surface(S) :-
val(S, mul(H, W)).</font></p>
<p><font size="2" face="Courier New">// An inheritance
rule.</font></p>
<p><font size="2" face="Courier New">Square(C) &lt;- Rectangle(C,
C).</font></p>
<p><font size="2" face=
"Courier New">Square(_)::[Square]-attr-&gt;[Beautiful].</font></p>
<p><font face="Garamond">Let us consider some requests :</font></p>
<p><font size="2" face="Courier New">?-
Rectangle(4,5)::G.</font></p>
<p><small><font face="Courier New">{G = [Rectangle]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-permOf-&gt;[Perimeter],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-surfOf-&gt;[Surface],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-widthOf-&gt;[Width = 5],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-heigthOf-&gt;[Heigth = 4]}</font></small></p>
<p><font size="2" face="Courier New">{G = Perimeter(18)}</font></p>
<p><font size="2" face="Courier New">{G = Surface(20)}</font></p>
<p><font face="Garamond">The next question illustrates the use of
constraints. The question is : is it possible to construct a
rectangle with Width = 5 and Height = 4 ? The answer to the
question is no because the associated constraint is not
verified.</font></p>
<p><font size="2" face=
"Courier New">?-Rectangle(5,4)::[Width=5]&lt;-widthOf-[Rectangle]-heigthOf-&gt;[Heigth=4].</font></p>
<p><font size="2" face="Courier New">no.</font></p>
<p><font face="Garamond">Finally, the next request illustrates
method inheritance :</font></p>
<p><font size="2" face="Courier New">?-
Square(4)::Perimeter(P).</font></p>
<p><font size="2" face="Courier New">{P = 16}</font></p>
<p>&nbsp;</p>
<p><a name="CreateInstance"></a><font face="Garamond"><b>The
primitive goal CreateInstance.</b></font> <font face=
"Garamond">PROLOG+CG provides the primitive goal</font> <font size=
"2" face="Courier New">CreateInstance(Ident, Term)</font>
<font face="Garamond">which enables the creation of an instance
Ident from an object identified by Term.</font></p>
<p><font face="Garamond">When executed,</font> <font size="2" face=
"Courier New">createInstance(Ident, Term)</font> <font face=
"Garamond">will add the following inheritance rule to the
program</font> <font size="2" face="Garamond">:</font> <font size=
"2" face="Courier New">Ident &lt;- Term</font><font face=
"Garamond">.</font></p>
<p><font face="Garamond">The following request illustrates the use
of createInstance (assuming the previous program of Rectangle and
Square) :</font></p>
<p><font size="2" face="Courier New">?- createInstance(sq1,
Square(6)), sq1::Surface(S).</font></p>
<p><font size="2" face="Courier New">{S = 36}</font></p>
<p>&nbsp;</p>
<p><strong><big><font face="Garamond"><big>22. <a name=
"PROLOG+CGandJAVA">PROLOG+CG and &nbsp; JAVA</a></big> (in
collaboration with Pr. Bernard Moulin and his students : Jeremi
Gancet, David Nadeau and Olivier Rouleau, from Laval
university)</font></big></strong></p>
<p><font face="Garamond">In the current version of Prolog+CG,
PROLOG+CG can be activated from a Java program and inversely, Java
components (i.e. methods and attributes of classes/objects) can be
activated from a Prolog+CG program. Figure 8 gives the part of the
primitive goals hierarchy that concerns this side of
PROLOG+CG.</font></p>
<p align="center"><img src="EnvPrimHier4.png" alt=
"EnvPrimHier4.png (23636 octets)"></p>
<p align="center"><font face="Garamond"><b><big>Figure 8 :
Primitives of PROLOG+CG related to the relation with
JAVA</big></b></font></p>
<p align="center">&nbsp;</p>
<ul>
<li><b><big>Calling Prolog+CG from Java programs</big></b></li>
</ul>
<p align="justify">The Prolog language provides powerful reasoning
and symbolic manipulation capabilities, but it is not well suited
to implement the interface functionalities (windows, menus, link to
data bases, etc.) that object-oriented languages provide. Hence, a
good development strategy consists in using each Prolog+CG
programming paradigm to implement the functionalities that it best
supports. It is recommended to develop programs using Java and to
call the Prolog+CG modules when it is appropriate. This section
presents a set of primitives that Prolog+CG 2.0 provides in order
to call Prolog+CG modules from Java programs. The use of these
primitives is illustrated using a simple example.</p>
<p align="justify"><b>Four primitives are used to exploit a
Prolog+CG program from a Java program</b></p>
<ul>
<li><b>void LoadFile(String fileName)</b> : <i>"fileName"</i> is
the name of a Prolog+CG program. The role of this primitive is to
load a Prolog+CG program contained in the file
<i>"fileName".</i></li>
<li><b>Vector Resolve(String Quest [, boolean ConvereResult] [,
boolean ExpertSystemMode])</b> : the parameter <i>"Quest"</i> is
the request that Prolog+CG should resolve. The optional parameter
<em>"ConverseResult"</em> specifies if the result should be
conversed to string or not (it is set to true by default), and
<i>"ExpertSystemMode",</i> if it is specified, is a boolean that
indicates if Prolog+CG should behave like an expert system shell or
like a Prolog interpreter. This argument is set to false by
default. The primitive goal Resolve/3 returns all the solutions in
a Vector of hashtables; one solution being represented by a
hashtable. Since a solution is a set of couples
&lt;VariableIdentifier, VariableValue&gt;, it is natural to
represent it as a hashtable with VariableIdentifier as a key. To
get the value of a variable in a solution, one has to use the
hashtable method "get(key)" where key stands for a variable
identifier. Any value of a variable is returned as a string (unless
the parameter <em>"ConverseResult"</em> is set to false). The
examples below illustrate this feature.</li>
<li><b>void SaveFile(String fileName)</b> : saves the current
program in the Prolog+CG file <i>"fileName".</i></li>
<li><b>void PurgeMemory()</b> : deletes the current Prolog+CG
program from memory.</li>
</ul>
<p align="justify"><b>Example 1 :</b></p>
<p align="justify">Assume that we have a Prolog+CG program
<i>"FamilyRelations.plgCG"</i> which contains, among other things,
the following facts and rules :</p>
<blockquote>
<blockquote>
<p align="justify"><font size="2" face="Courier New">[Man :
John]-fatherOf-&gt;[Man : Peter].</font></p>
<p align="justify">[Woman : Deborah]-fatherOf-&gt;[Man :
Peter].</p>
<p align="justify">[Man : John]-motherOf-&gt;[Woman : Clara].</p>
<p align="justify">[Person : x]-parentOf-&gt;[Man : y] :-</p>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp; [Person :
x]-fatherOf-&gt;[Man : y].</p>
<p align="justify">[Person : x]-parentOf-&gt;[Woman : y] :-</p>
<blockquote>
<p align="justify">[Person : x]-motherOf-&gt;[Woman : y].</p>
</blockquote>
</blockquote>
</blockquote>
<p align="justify">From a Java program, we can assert new facts and
retract existing facts from the above Prolog+CG program and we can
ask questions and get answers.</p>
<p align="justify">Here is an example of such an interaction. The
Java file :</p>
<p align="justify"><font face="Courier New"><small>//PrologPlusCG
is implemented as a Java Package<br>
import PrologPlusCG.PrologPlusCGFrame;<br>
...<br>
public void example() {<br>
&nbsp;&nbsp;&nbsp; ... any Java code<br>
&nbsp;&nbsp;&nbsp; <em>// Load a Prolog+CG File</em><br>
&nbsp;&nbsp;&nbsp; LoadFile("FamilyRelations.plgCG");<br>
&nbsp;&nbsp;&nbsp; ... any Java code<br>
&nbsp;&nbsp;&nbsp; <em>// Resolve a question</em><br>
&nbsp;&nbsp;&nbsp; Vector solutions = Resolve("[Person :
x]-parentOf-&gt;[Person : y]");<br>
&nbsp;&nbsp;&nbsp; <em>// Make access to the solutions and to their
content</em><br>
&nbsp;&nbsp;&nbsp; Hashtable solution;<br>
&nbsp;&nbsp;&nbsp; String valX, valY;<br>
&nbsp;&nbsp;&nbsp; For (Enumeration e = solutions.elements();
e.hasMoreElements();) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// make access to a
solution</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solution = (Hashtable)
e.nextElement();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// make access to the
variable's value for the solution</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valX = (String)
get("x");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valY = (String)
get("y");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>// make use of the
variable's value</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; };<br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; <em>// assert a new fact in the Prolog+CG
program</em><br>
&nbsp;&nbsp;&nbsp; Resolve("asserta([Man : Marc]-fatherOf-&gt;[Man
: Clark], ())");<br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; <em>// Save the current program in a new
file</em><br>
&nbsp;&nbsp;&nbsp; SaveFile("FamilyRels1.plgCG");<br>
&nbsp;&nbsp;&nbsp; <em>// Purge the current program from the
memory</em><br>
&nbsp;&nbsp;&nbsp; PurgeMemory();<br>
&nbsp;&nbsp;&nbsp; ...</small></font></p>
<p align="justify"><strong>Example 2 :</strong> <em>A simple
syntaxic analyzer</em></p>
<ul>
<li>
<p align="justify">The Prolog+CG program : file
"AnalyseSynt.plgCG"</p>
</li>
</ul>
<blockquote>
<p align="justify"><small><font face="Courier New">sentence(p,
ph(_np, _vp)) :-<br>
&nbsp;&nbsp;&nbsp; read_sentence(p, L),<br>
&nbsp;&nbsp;&nbsp; np(L, L1, _np),<br>
&nbsp;&nbsp;&nbsp; vp(L1, (), _vp), /.<br>
<br>
np((_det, _adj, _noun|L), L, np(det(_det), adj(_adj), noun(_noun))
) :-<br>
&nbsp;&nbsp;&nbsp; det(_art),<br>
&nbsp;&nbsp;&nbsp; adj(_adj),<br>
&nbsp;&nbsp;&nbsp; noun(_noun), /.<br>
<br>
vp((_verb|L), L1, vp(verb(_verb), _np)) :-<br>
&nbsp;&nbsp;&nbsp; verb(_verb),<br>
&nbsp;&nbsp;&nbsp; np(L, L1, _np), /.<br>
<br>
<br>
det("the").<br>
det("a").<br>
adj("beautiful").<br>
noun("girl").<br>
noun("apple").<br>
verb("eat").<br>
verb("eats").</font></small></p>
</blockquote>
<ul>
<li>
<p align="justify">The Java program : file
"FrmAnalyseSyntaxique.java"</p>
</li>
</ul>
<p align="justify"><font face="Courier New"><small>import
javax.swing.*;<br>
import java.awt.*;<br>
import java.util.*;<br>
import java.awt.event.*;<br>
import javax.swing.JTree.*;<br>
import javax.swing.tree.*;<br>
import PrologPlusCG.PrologPlusCGFrame;<br>
<br>
public class FrmAnalyseSyntaxique extends JFrame {<br>
<br>
&nbsp; JTextArea jTextArea1 = new JTextArea();<br>
&nbsp; JScrollPane jspTextArea = new JScrollPane(jTextArea1);<br>
<br>
&nbsp; JButton BtAnalyse = new JButton();<br>
&nbsp; JButton BtNouvPhrase = new JButton();<br>
&nbsp; JButton BtFin = new JButton();<br>
<br>
&nbsp; JPanel jpnl = new JPanel();<br>
&nbsp; JTree jTree1;<br>
&nbsp; JScrollPane jspArbre;<br>
<br>
&nbsp; public static void main(String [] args) {<br>
&nbsp;&nbsp;&nbsp; FrmAnalyseSyntaxique unFrm = new
FrmAnalyseSyntaxique();<br>
&nbsp; }<br>
<br>
&nbsp; public FrmAnalyseSyntaxique() {<br>
&nbsp;&nbsp;&nbsp; super();<br>
&nbsp;&nbsp;&nbsp; try {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jbInit();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.show();<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; catch (Exception e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp; }</small></font></p>
<p align="justify"><font face="Courier New"><small><br>
&nbsp; private void jbInit() throws Exception {<br>
&nbsp;&nbsp;&nbsp; setTitle("Analyse Syntaxique");<br>
&nbsp;&nbsp;&nbsp; getContentPane().setLayout(new
BorderLayout());<br>
&nbsp;&nbsp;&nbsp; setSize(new Dimension(400, 500));<br>
<br>
&nbsp;&nbsp;&nbsp; jspTextArea.setMinimumSize(new Dimension(400,
350));<br>
&nbsp;&nbsp;&nbsp; jspTextArea.setMaximumSize(new Dimension(400,
350));<br>
&nbsp;&nbsp;&nbsp; jspTextArea.setBackground(SystemColor.info);<br>
&nbsp;&nbsp;&nbsp; jTextArea1.setText(" ");<br>
<br>
&nbsp;&nbsp;&nbsp; BtAnalyse.setLabel("Analyse");<br>
&nbsp;&nbsp;&nbsp; BtAnalyse.setPreferredSize(new Dimension(100,
100));<br>
&nbsp;&nbsp;&nbsp; BtAnalyse.addActionListener(new
java.awt.event.ActionListener() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void
actionPerformed(ActionEvent e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BtAnalyse_actionPerformed(e);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; });<br>
&nbsp;&nbsp;&nbsp; BtNouvPhrase.setLabel("Nouvelle Phrase");<br>
&nbsp;&nbsp;&nbsp; BtNouvPhrase.setPreferredSize(new Dimension(100,
100));<br>
&nbsp;&nbsp;&nbsp; BtNouvPhrase.addActionListener(new
java.awt.event.ActionListener() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void
actionPerformed(ActionEvent e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BtNouvPhrase_actionPerformed(e);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; });<br>
&nbsp;&nbsp;&nbsp; BtFin.setLabel("Fin");<br>
&nbsp;&nbsp;&nbsp; BtFin.setPreferredSize(new Dimension(100,
100));<br>
&nbsp;&nbsp;&nbsp; BtFin.addActionListener(new
java.awt.event.ActionListener() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void
actionPerformed(ActionEvent e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
BtFin_actionPerformed(e);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; });</small></font></p>
<p align="justify"><font face="Courier New"><small><br>
&nbsp;&nbsp; jpnl.setPreferredSize(new Dimension(400, 350));<br>
&nbsp;&nbsp; jpnl.setBackground(SystemColor.info);<br>
<br>
&nbsp;&nbsp; getContentPane().add(jspTextArea,
BorderLayout.NORTH);<br>
&nbsp;&nbsp; getContentPane().add(BtAnalyse,
BorderLayout.WEST);<br>
&nbsp;&nbsp; getContentPane().add(BtNouvPhrase,
BorderLayout.CENTER);<br>
&nbsp;&nbsp; getContentPane().add(BtFin, BorderLayout.EAST);<br>
&nbsp;&nbsp; getContentPane().add(jpnl, BorderLayout.SOUTH);<br>
}<br>
<br>
void BtAnalyse_actionPerformed(ActionEvent e) {<br>
&nbsp;&nbsp; PrologPlusCGFrame.LoadFile("AnalyseSynt.plgCG");<br>
&nbsp;&nbsp; Vector vect = PrologPlusCGFrame.Resolve("sentence(\""
+ jTextArea1.getText() + "\", x).",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
false);<br>
<em>// false in Resolve : indicates that the result shouldn't be
conversed to String</em><br>
&nbsp; if (vect == null)<br>
&nbsp;&nbsp;&nbsp; JOptionPane.showMessageDialog(this, "The
sentence is ungrammatical.", "Warning",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
JOptionPane.OK_OPTION);<br>
&nbsp; else { <em>// Draw the syntaxic tree</em><br>
&nbsp;&nbsp;&nbsp; Hashtable solution = (Hashtable)
vect.firstElement();<br>
&nbsp;&nbsp;&nbsp; getContentPane().remove(jpnl);<br>
&nbsp;&nbsp;&nbsp; jTree1 = new JTree((Vector)
solution.get("x"));<br>
&nbsp;&nbsp;&nbsp; jspArbre = new JScrollPane(jTree1);<br>
&nbsp;&nbsp;&nbsp; getContentPane().add(jspArbre,
BorderLayout.SOUTH);<br>
&nbsp;&nbsp;&nbsp; show();<br>
&nbsp; };<br>
<br>
}<br>
<br>
void BtNouvPhrase_actionPerformed(ActionEvent e) {<br>
jTextArea1.setText("");<br>
try {<br>
&nbsp;&nbsp;&nbsp; this.getContentPane().remove(jspArbre);<br>
&nbsp;&nbsp;&nbsp; jspArbre.remove(jTree1);<br>
&nbsp;&nbsp;&nbsp; jTree1.removeAll();<br>
&nbsp;&nbsp;&nbsp; jTree1 = null;<br>
&nbsp;&nbsp;&nbsp; jspArbre = null;<br>
this.getContentPane().add(jpnl, BorderLayout.SOUTH);<br>
}<br>
catch(Exception ex) {};<br>
show();<br>
}<br>
<br>
void BtFin_actionPerformed(ActionEvent e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(0);<br>
}<br>
}</small></font></p>
<p align="justify"><font face="Garamond">Figure 9 shows a snapshot
of the directory and the DOS console just before the execution of
the above Java file.</font></p>
<p align="center"><img src="AppelAnalSynt.png" alt=
"AppelAnalSynt.png (21967 octets)"></p>
<p align="center"><strong>Figure 9 :</strong> snapshot of the
directory and the DOS console just before the execution of the
above Java file</p>
<p align="justify">Figure 10 shows the result of the execution of
the above Java file.</p>
<p align="center"><img src="AnalSynt1.png" alt=
"AnalSynt1.png (4281 octets)">&nbsp;&nbsp;<img src="AnalSynt2.png"
alt="AnalSynt2.png (9808 octets)"></p>
<p align="justify">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(a) before the analysis
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(b) after the analysis</p>
<p align="center"><strong>Figure 10 :</strong> The result of the
execution of the Java Program</p>
<p align="justify">The four primitives "LoadFile", "Resolve",
"SaveFile" and "PurgeMemory" are "external" primitives of Prolog+CG
: they are used in a Java Program to make use of a Prolog+CG
program. These simple external commands may look like details but
they are a tremendous step forward in making the Prolog+CG language
a concrete development tool. The interface inability to convey a
sense of usability and user-friendliness has long been a major
obstacle in using logic programs in real end-user developments.</p>
<p align="justify">For instance, it is not unusual to have many
lines of Prolog code to enter before making a useful query. In
addition, a lot of parameters in these lines of code are very
sensible to error and require that the user know the program's
internal workings fairly well to be able to get any valuable
information from the system. In addition, the answer has the
typical Prolog form (an output list) and it is sometimes very hard
to read. The output list (i.e. the solution) is neither sorted
alphabetically nor numerically. Finally, if the user wants
additional information on one of the listed items, an additional
query is necessary.</p>
<p align="justify">All these considerations find an elegant
solution using the <i>Java/Prolog+CG</i> interface. We have used
this interface to develop a simple Prolog+CG program (Figure 11).
The front/end interface has been implemented using Java and the
reasoning part using Prolog+CG. The input screen (Figure 11.a)
offers lists and slider bars and actually writes in the Prolog+CG
program four assertions for the user, using his selections. A
results-screen (Figure 11.b) then presents the output list which
can be sorted using any criteria. Additional information on a given
list item can be obtained with the simple press of a button (Figure
11.b).</p>
<p align="center"><img src="Prolog1.jpg" alt=
"wpe2.jpg (7562 octets)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img src="Prolog2.jpg" alt="wpe5.jpg (10872 octets)"><img src=
"Prolog3.jpg" alt="wpe6.jpg (4354 octets)">&nbsp;</p>
<p align="center"><font face="Garamond">(a) an input screen
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(b) output screens</font></p>
<p align="center"><b>Figure 11 :</b> front/end interface for a
Prolog+CG program</p>
<p align="justify">Using this example, we wanted to emphasize the
importance of having interfaces between languages thus allowing
each to be used for what it is best at. This Prolog+CG
functionality makes it a concrete development tool easily usable in
real projects. By allowing evolved logic reasoning to be used in
simple user-friendly applications as well as complex Java code, the
language moves beyond the traditional academic boundaries.</p>
<p align="justify"><strong>Note :</strong> The <a href=
"#ExpertMode">The Expert System Mode</a> of Prolog+CG can be
exploited from a Java program by using the primitives described in
this Section. In this case, the second argument of the primitive
"Resolve/2" should be used and should be set to "true".</p>
<p align="justify">&nbsp;</p>
<ul>
<li><big><strong>Calling applications from a Prolog+CG
program</strong></big></li>
</ul>
<p align="justify">Prolog+CG 2.5 provides two primitives which
allow calling an executable application from a Prolog+CG program.
This is another way to make use of Prolog+CG 's capabilities to
work as a component of a larger system.</p>
<ul>
<li><b>exec(ExecFileName) :</b> starts the execution of the
application <i>"ExecFileName"</i> and continues the current
resolution.</li>
<li><b>execAndWait(ExecFileName) :</b> starts the execution of the
application <i>"ExecFileName"</i> and waits for its termination.
Then it resumes the current resolution of the Prolog+CG
program.</li>
</ul>
<p align="justify"><b>Example&nbsp; :</b></p>
<p><small><font face="Courier New">ex1 :-</font></small></p>
<blockquote>
<p><small><font face="Courier New">eq(x, 45),</font></small></p>
<p><small><font face=
"Courier New">exec("Synergy.exe"),</font></small></p>
<p><small><font face="Courier New">write("Continue without waiting
for the end of Synergy..."), /.</font></small></p>
</blockquote>
<p><small><font face="Courier New">ex2 :-</font></small></p>
<blockquote>
<p><small><font face="Courier New">eq(x, 45),</font></small></p>
<p><small><font face=
"Courier New">execAndWait("Synergy.exe"),</font></small></p>
<p align="justify"><small><font face="Courier New">write("Continue
after the end of Synergy ..."), /.</font></small></p>
<p align="justify">&nbsp;</p>
</blockquote>
<p align="justify"><font face="Garamond">The result of the
execution of ex1 :</font></p>
<p align="center"><font face="Garamond"><img src="PPCGSYN.png" alt=
"PPCGSYN.png (52070 octets)"></font></p>
<p align="center">&nbsp;</p>
<ul>
<li><b><big>Using Java code from Prolog+CG</big></b></li>
</ul>
<p align="justify">Prolog+CG 2.5 provides several primitives
allowing the use of Java code and providing access to
object-oriented capabilities. Indeed, new Java objects can be
created, used and destroyed from a Prolog+CG program. These objects
are considered as "global objects" of a Prolog+CG program.</p>
<p align="justify">This section presents these primitives and
briefly illustrates their use.</p>
<ul>
<li><b>new(NewObjectIdent, JavaClass, ConstructorArguments) :</b>
this primitive goal enables the creation of a new Java object. It
corresponds to the following Java instruction :</li>
</ul>
<blockquote>
<blockquote>
<p align="justify">JavaClass NewObjectIdent = <b>new</b> JavaClass
ConstructorArguments;</p>
</blockquote>
</blockquote>
<ul>
<li><b>destroy(ObjectIdent)</b> : this primitive goal destroys the
Java object identified by <i>"ObjectIdent"</i>.</li>
<li><b>destroyAll</b> : this primitive goal destroys all the Java
objects that have been created in the current program.</li>
<li><b>get(Data, AttributeIdent, ObjectIdent)</b> : this primitive
goal can be used to get the value of the attribute
<i>"AttributeIdent"</i> of the object <i>"ObjectIdent".</i> The
value is then unified with the first argument <i>"Data".</i></li>
<li><b>set(Data, AttributeIdent, ObjectIdent)</b> : this primitive
goal can be used to set <i>"Data"</i> as the value of the attribute
<i>"AttributeIdent"</i> of the object <i>"ObjectIdent".</i></li>
<li><b>execMethod(Data_Or_void, JavaClass_Or_ObjectIdent,
MethodIdent, MethodArguments) :</b> this primitive goal can be used
to call a method "MethodIdent", of a Java class (in the case of a
static method) or of a Java object "JavaClass_Or_ObjectIdent" with
the argument list "MethodArguments". If the method is of type void
then the first argument of the primitive execMethod should be the
keyword "void". Otherwise, the returned value is unified with the
first argument "Data_Or_void".</li>
</ul>
<ul>
<li><b>val(VariableIdent_Or_ObjectIdent, Expression_Or_ObjectIdent)
:</b> this primitive goal determines the value of its second
argument, which could be an expression or an object identifier. The
value of the expression (or the object) is then associated to the
variable (or to the object).</li>
</ul>
<p>With calling Java code from Prolog+CG predicates
and&nbsp;calling Prolog+CG from Java code, the loop is closed and
the language offers both a powerful new representational
programming paradigm and an integrated way to access it
conveniently.</p>
<p><font face="Garamond"><strong>Example 1 :</strong> this simple
example shows how an object (of a primitive or a defined Java
class) can be created and how the object methods can be
invoked.</font></p>
<p><small><font face="Courier New">explePPCGToJava(x,y) :-<br>
&nbsp;&nbsp;&nbsp; new(vct, "java.util.Vector", ()),<br>
&nbsp;&nbsp;&nbsp; execMethod(void, vct, "addElement", (4)),<br>
&nbsp;&nbsp;&nbsp; execMethod(void, vct, "addElement", (6)),<br>
&nbsp;&nbsp;&nbsp; execMethod(void, vct, "addElement", (10)),<br>
&nbsp;&nbsp;&nbsp; execMethod(void, vct, "addElement", (14)),<br>
&nbsp;&nbsp;&nbsp; execMethod(x, vct, "size", ()),<br>
&nbsp;&nbsp;&nbsp; execMethod(y, vct, "elementAt",
(2)).</font></small></p>
<p>&nbsp;</p>
<p><font face="Courier New"><small>?- explePPCGToJava(x,y).<br>
<br>
{x = 4, y = 10}<br>
<br>
?-</small></font></p>
<p>&nbsp;</p>
<p><font face="Garamond">The next example shows the extendable
feature of Prolog+CG. Suppose for instance that someone needs a
primitive to convert a string to an integer. Instead of adding a
new primitive to Prolog+CG to do that, the user can use Java
directly for that. It corresponds to a call to a method of a class
in Java that do such a job :</font></p>
<p><font face="Courier New"><small>?- execMethod(c,
"java.lang.Integer", "valueOf", ("345")), sup(c,
300).</small></font></p>
<p><font face="Courier New"><small>{c = 345}</small></font></p>
<p>&nbsp;</p>
<p><font face="Garamond"><strong>Example 2 : <em>An application
that calls Java code : SHRDLU-PCG</em></strong><br>
To illustrate the expressive power of Prolog+CG and to show its
usefulness for the development of natural language processing
applications, we developed SHRDLU-PCG, a reformulation in Prolog+CG
of some aspects of the classic SHRDLU program [10]. In the
Prolog+CG program (see below), one can note the natural use of CG
as a data structure, beside term and list, and also the very use of
variables in CG : a variable can hold for a CG, a concept, a
concept type, a referent, a co-referent, a concept description (or
value) and a relation. This flexibility is very important from a
programming perspective.<br>
SHRDLU-PCG also illustrates how Java classes (and their attributes
and methods) can be used from a Prolog+CG program.<br>
SHRDLU-PCG simulates a very restricted natural language dialog
between a user and a robot that operates in a block-world. The
robot can create, move, push and pop 3D blocks. The robot is able
to "understand" declarative, imperative and interrogative sentences
and to react accordingly. The 3D animation that results from such a
dialog is monitored thanks to the "cooperation" of the Prolog+CG
program SHRDLU-PCG with a Java3D program which provides the
capability to create a 3D canvas, to fill it with 3D objects (cube,
cylinder, sphere, pyramid) and to do some actions on them.<br>
<br>
First, let us consider how the semantic analysis of a sentence and
especially the analysis of an imperative sentence is carried out.
Examples of imperative sentences are "create a red pyramid
pyramid4.", "push the red pyramid on the big cube." and "move the
blue sphere at the left of cube1.".<br>
As the components of the sentence are analyzed, CGs that represent
their semantic meaning are constructed and then joined. This
dynamic construction of CGs is in itself an important feature of
Prolog+CG.<br>
<br></font> <small><font face="Courier New"><em>// lexicon(Word,
SyntaxicCategory, TypeOrCGCanon)<br></em>lexicon("push", verb,
[Push]-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; -obj-&gt;[Object],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; -on-&gt;[Object] ).<br>
lexicon("create", verb,
[Create]-obj-&gt;[Object]-colorOf-&gt;[Color]).<br>
Lexicon("sphere", noun, Sphere).<br>
<br>
Verb(V, _CGCanon) :- lexicon(V, verb, _CGCanon).<br>
<br>
<em>// Syntax of imperative-sentence = Verb NP Complement.<br>
// Complement = [Prep NP].<br></em>imperative_sentence((V|P1),
[Proposition : G]-mode-&gt;[Modality : imperative]) :-<br>
&nbsp;&nbsp;&nbsp; Verb(V, G_V),<br>
&nbsp;&nbsp;&nbsp; NP(P1, P2, E_NP1, S1),<br>
&nbsp;&nbsp;&nbsp; eq([T_Verb]-obj-&gt;E_N_G1, G_V),<br>
&nbsp;&nbsp;&nbsp; maximalJoin(G_V, E_N_G1, S1, E_NP1, G1_S1,
_),<br>
&nbsp;&nbsp;&nbsp; complement(P2, T_Verb, G1_S1,
G).<br></font></small><font face="Garamond"><br>
<br>
<em>Comment on Verb/2 :</em> checks if V is a verb, if so, return
the canon of the verb.<br>
<br>
<em>Comment on imperative_sentence/2 :</em><br>
imperative_sentence(P, G) receives a sentence P, as a list of
words, and produces a CG G that represents its meaning. It starts
by recognizing the verb and then the noun phrase. The canon of the
verb (G_V) is then joined with the CG corresponding to the noun
phrase (S1). This maximal join should satisfy however the following
constraint : the concept that represents the head of the noun
phrase has to be joined with the concept that represents the object
of the verb. So we have to locate these two concepts in the two CGs
respectively and then we have to consider them as "entry concepts"
for the maximal join in question; this later should start by the
join of the two entry concepts.<br>
The entry concept for the CG G_V that represents the semantic
meaning of the verb is located by the following goal
:&nbsp;&nbsp;&nbsp;&nbsp;</font></p>
<p><font face="Garamond">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
eq([T_Verb]-obj-&gt;E_N_G1, G_V).</font></p>
<p><font face="Garamond"><br>
To understand the effect of the above goal, let's consider this
request :</font></p>
<p><font face="Garamond"><br></font><small><font face=
"Courier New">?- eq(G_V,[Create]-obj-&gt;[Sphere:sphere1]),
eq([T_Verb]-obj-&gt;E_N_G1, G_V).<br>
{G_V = [Create]-obj-&gt;[Sphere:sphere1], T_Verb = Create,E_N_G1 =
[Sphere:sphere1]}<br></font></small><font face="Garamond"><br>
As a result of the above unification eq/2, the variable "E_N_G1"
refers to the concept in G_V that represents the object of the
verb. Note how the variable "T_Verb" stands for the type of the
concept and the variable "E_N_G1" stands for the whole concept.<br>
The defined goal NP/4 : NP(P1, P2, E_NP1, S1) returns the graph S1
that represents the meaning of the noun phrase as well as the entry
concept E_NP1 in S1.<br>
After the analysis of the verb and the noun phrase, the maximal
join of their semantic representations is done, producing a CG
G1_S1 and then, the semantic analysis of the complement is
initiated. If the complement is specified, its semantic
representation will be computed and then joined with the CG
G1_S1.<br>
<br>
After the semantic analysis of an imperative sentence, the "robot"
will consider its meaning as an order to be executed. Hence and as
a result of such an execution, the knowledge of the "robot" will
change (for instance, the position of an object has to be modified)
as well as the 3D animation that shows the visual simulation of the
robot behavior. The following Prolog+CG code shows how all these
aspects are related.<br>
<br></font><small><font face="Courier New">Shrdlu :-<br>
&nbsp;&nbsp;&nbsp; new(aShrdlu_Canvas3D,
"PrologPlusCG.Shrdlu_Canvas3D", ()),<br>
&nbsp;&nbsp;&nbsp; read_sentence(_sentence),<br>
&nbsp;&nbsp;&nbsp; ShrdluDialog(_sentence), /.<br>
<br>
ShrdluDialog(("end", ".")) :- /.<br>
ShrdluDialog(_sentence) :-<br>
&nbsp;&nbsp;&nbsp; Semantic_Analysis(_sentence,
_CG),&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp; _CG,<br>
&nbsp;&nbsp;&nbsp; read_sentence(_s),<br>
&nbsp;&nbsp;&nbsp; ShrdluDialog(_s),
/.<br></font></small><font face="Garamond"><br>
<br>
<em>Comment on the main goal Shrdlu :</em> this goal initiates the
3D simulation as well as the restricted natural language dialog. In
particular, it specifies a call to the primitive goal "new" in
order to create an instance of the defined Java 3D class
Shrdlu_Canvas3D. Such a creation will involve, among other actions,
the display of a frame that contains a "robot" (Figure 10.a).<br>
<br>
Comment on the goal ShrdluDialog : in the above definition of
"ShrdluDialog" goal, note how the meaning of the sentence (i.e. the
CG "_CG" that results from the semantic analysis of "_sentence") is
put as a goal to be interpreted. Thus, in the case of an imperative
sentence, the goal-variable "_CG" will be bound to the following CG
: [Proposition : G]-mode-&gt;[MODALITY : imperative]<br>
<br>
The proposition G (the variable G will be bound to a CG) is
interpreted as an order that should be satisfied. Here is the
Prolog+CG rule that naturally formulates this interpretation :<br>
<br>
<br></font><small><font face="Courier New">&nbsp;&nbsp;&nbsp;
[Proposition : G]-mode-&gt;[MODALITY : imperative] :-
G.</font></small><font face="Garamond"><br>
<br>
<br>
Each order is then executed according to its semantic
interpretation. For instance, the order to create an object with a
specific name and color is defined as follows : first assert the
existence of the object in the data base, then create a physical
object in the 3D canvas. Each kind of object (Cube, Sphere,
Pyramid) is created by a corresponding method in the defined Java
class "Shrdlu_Canvas3D" (Figure 10.b).<br>
<br>
<br></font><font face="Courier New"><small>[Create]-obj-&gt;[T_Obj
: _IdObj]-colorOf-&gt;[Color : C] :-<br>
&nbsp;&nbsp;&nbsp; asserta(object([T_Obj :
_IdObj]-colorOf-&gt;[Color : C]), ()),<br>
&nbsp;&nbsp;&nbsp; execMethod(void, "PrologPlusCG.Shrdlu_Canvas3D",
T_Obj, (_IdObj, C)),<br>
&nbsp;&nbsp;&nbsp; /.<br></small></font><font face=
"Garamond"><br></font><small><font face="Courier New">?-
Shrdlu.<br>
<br>
|:create the green sphere sphere1.</font></small></p>
<p>&nbsp;</p>
<p align="center"><font face=
"Garamond">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img src="Image1.png" width="235" height="207">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img src="Image2.png" width="250" height=
"206">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></p>
<p align="center">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(a)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(b)</p>
<p align="center"><strong>Figure 10 :</strong> SHRDLU_PCG in
action</p>
<p><big><big><a name="Appendix"></a><font face=
"Garamond"><b>Appendix&nbsp;: The grammar of
PROLOG+CG</b></font></big></big></p>
<p><font size="2" face="Courier New">Prolog+CGProgram = (Rule |
Comment) {(Rule | Comment)} .</font></p>
<p><font size="2" face="Courier New">Rule = Specialization_Rule |
Instantiation_Rule |</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="11%"></td>
<td valign="top" width="89%"><font size="2" face=
"Courier New">Generalization_Rule | Inference_Rule.</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">Specialization_Rule =
TypeIdentifier "&gt;" TypeIdentifier</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="30%"></td>
<td valign="top" width="70%"><font size="2" face="Courier New">{","
TypeIdentifier} "." .</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">Instantiation_Rule =
TypeIdentifier "=" ReferentIdentifier</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="31%"></td>
<td valign="top" width="69%"><font size="2" face="Courier New">{","
ReferentIdentifier} ".".</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">Generalization_Rule =
ObjDescriptor "&lt;-" ObjDescriptor "." .</font></p>
<p><font size="2" face="Courier New">Inference_Rule = Head [":-"
Tail] "." .</font></p>
<p><font size="2" face="Courier New">Tail = Goal {","
Goal}.</font></p>
<p><font size="2" face="Courier New">Goal = SimpleGoal ["::"
SimpleGoal].</font></p>
<p><font size="2" face="Courier New">SimpleGoal = Term | CG |
Variable .</font></p>
<p><font size="2" face="Courier New">Head = SimpleHead ["::"
(SimpleHead | Variable)] .</font></p>
<p><font size="2" face="Courier New">SimpleHead = (Term |
CG).</font></p>
<p><font size="2" face="Courier New">ObjDescriptor = Term
.</font></p>
<p><font size="2" face="Courier New">Term = Identifier [ "("
PrlgCGData {"," PrlgCGData} ")" ] .</font></p>
<p><font size="2" face="Courier New">List = "(" [ PrlgCGData {","
PrlgCGData} [ "|" Variable ] ] ")" .</font></p>
<p><font size="2" face="Courier New">PrlgCGData = Number | Boolean
| Identifier | String |</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="19%"></td>
<td valign="top" width="81%"><font size="2" face=
"Courier New">Variable | List | Term | CG .</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">CG = Concept [OutBranch |
InBranch | Branchs] .</font></p>
<p><font size="2" face="Courier New">Branchs = "-" (OutBranch |
InBranch)</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="21%"></td>
<td valign="top" width="79%"><font size="2" face="Courier New">{","
(OutBranch | InBranch) } [","] .</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">OutBranch = "-"
RelationIdentifier "-&gt;" CG .</font></p>
<p><font size="2" face="Courier New">InBranch = "&lt;-"
RelationIdentifier "-" CG .</font></p>
<p><font size="2" face="Courier New">Concept = "[" Type [":"
Referent] ["=" Value] "]" .</font></p>
<p><font size="2" face="Courier New">Type = TypeIdentifier |
Variable .</font></p>
<p><font size="2" face="Courier New">Referent = ReferentIdentifier
| Multi_Referent | Variable.</font></p>
<p><font size="2" face="Courier New">Value = PrlgCGData
.</font></p>
<p><font size="2" face="Courier New">Comment = "//" {Character}
.</font></p>
<p><font size="2" face="Courier New">TypeIdentifier,
ReferentIdentifier,</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="22%"></td>
<td valign="top" width="78%"><font size="2" face=
"Courier New">RelationIdentifier = Identifier .</font></td>
</tr>
</table>
<p><font size="2" face="Courier New">Multi_Referent = "*" {Digit}
.</font></p>
<p><font size="2" face="Courier New">Number = Digit { Digit }
.</font></p>
<p><font size="2" face="Courier New">Boolean = "true" | "false"
.</font></p>
<p><font size="2" face="Courier New">Identifier = Letter Letter {
Letter | Digit | "_" } .</font></p>
<p><font size="2" face="Courier New">String = """ { Letter | Digit
| "_" } """ .</font></p>
<p><font size="2" face="Courier New">Variable = ("_" { Letter |
Digit | "_" }) | Letter |</font></p>
<table border="0" cellpadding="4" cellspacing="0" width="571">
<tr>
<td valign="top" width="16%"></td>
<td valign="top" width="84%"><font size="2" face="Courier New">(
Letter (Digit | "_") { Letter | Digit | "_" } ).</font></td>
</tr>
</table>
<p>&nbsp;</p>
<p><big><big><font face=
"Garamond"><b>References</b></font></big></big></p>
<ol>
<li><font face="Garamond" size="3">Ait-Kaci H. and R. Nasr. (1986),
LOGIN : A logic programming language with built-in inheritance,
Journal Logic Programming, 3, pp. 185-215.</font></li>
<li><font face="Garamond" size="3">Ait-Kaci H. and A. Podelski
(1992), Logic programming with functions over order-sorted feature
terms, in E. Lamma and P. Mello (Eds.), Extensions of Logic
Programming, Springer-Verlag, pp. 100-119.</font></li>
<li><font face="Garamond" size="3">Carpenter B. (1992), The logic
of typed feature structures, Cambridge Univ. Press.</font></li>
<li><font face="Garamond" size="3">Dichev C. (1993), Distributed
knowledge and data processing, in Proceeding of ICO'93
Montreal, Canada, pp. 279-282.</font></li>
<li><font face="Garamond" size="3">Dichev C. (1992), Logic
programming with worlds, in AI : Methodology, Systems,
Applications, North-Holland, pp. 57-67.</font></li>
<li><font face="Garamond" size="3">Fargues J., Landau M-C, Duguord
A. and Catach L. (1986), Conceptual Graphs for semantics and
knowledge processing, IBM Journal of Research and Development, vol.
30:1, pp. 70-79.</font></li>
<li><font face="Garamond" size="3">Fukunaga K. and S. Hirose
(1986), An experience with a Prolog-based object-oriented language,
in Proc. Of OOPSLA'86, pp. 224-231.</font></li>
<li><font face="Garamond" size="3">Garner B. J. and E. Tsui (1988),
General purpose inference engine for canonical graph models,
knowledge-Based Systems, 1:5, pp. 266-278.</font></li>
<li><font face="Garamond" size="3">Garner B. J., E. Tsui, D. Lui,
D. Lukose and J. Koh (1992), Extendible Graph Processing in
Knowledge Acquisition, Planning and Reasoning, in Nagle T. E., J.
A. Nagle, L. L. Gerholz and P. W. Eklund (Eds.), Conceptual
Structures : Current research and practice, Ellis
Horwood.</font></li>
<li><font face="Garamond" size="3">Herzog O. and C. &ndash;R.
Rollinger (Eds.) (1991), Text Understanding in LILOG,
Springer-Verlag.</font></li>
<li><font face="Garamond" size="3">Kabbaj A., C. Frasson, M.
Kaltenbach and J-Y Djamen (1994), A Conceptual and Contextual
Object-Oriented Logic Programming : The PROLOG++ language, in W. M.
Tepfenhart, J. P. Dick and J. F. Sowa (Eds.), Conceptual Structures
: Current Practices, ICCS'94, pp. 251-274.</font></li>
<li><font face="Garamond" size="3">Kabbaj A. (1996), Un systeme
multi-paradigme pour la manipulation des connaissances utilisant la
theorie des graphes conceptuels, Ph. D. Thesis, Univ. De Montreal,
Canada.</font></li>
<li><font face="Garamond" size="3">Kabbaj A. (1995),
Self-Organizing Knowledge Bases : The Integration Based Approach,
in the Proc. Of the Int. KRUSE Symposium : Knowledge Retrieval,
Use, and Storage for Efficiency, Santa Cruz, CA, USA, p.
64-68.</font></li>
<li><font face="Garamond" size="3">Kauffmann H. and A. Grumbach
(1986), MULTILOG : MULTIple worlds in LOGic programming, in the
proceeding of the 7<sup>th</sup> European Conference on
AI.</font></li>
<li><font face="Garamond" size="3">McCabe F. G. (1992), L&amp;O :
Logic and Objects, Prentice-Hall.</font></li>
<li><font face="Garamond" size="3">Monteiro L. and A. Porto (1989),
Contextual Logic Programming, in G. Levi and M. Martelli (Eds.),
Proc. 6<sup>th</sup> Int. Conf. And Symposium on Logic Programming,
MIT Press.</font></li>
<li><font face="Garamond" size="3">Moss C. (1994), Prolog++, The
Power of Object-Oriented and Logic Programming,
Addison-Wesley.</font></li>
<li><font face="Garamond" size="3">Pletat U. and K. von Luck
(1990), Knowledge Representation in LILOG, in Blasius and al.
(Eds.), Sorts and Types in Artificial Intelligence, LNAI
n<sup>o</sup>. 418, Springer-Verlag.</font></li>
</ol>
</body>
</html>
